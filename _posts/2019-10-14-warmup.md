---
title: 清华校赛THUCTF2019 之 warmup
date: 2019-10-14 00:00:00
categories:
- CTF/Pwn
tags: fork函数利用 任意地址写 任意地址读 libc基址泄露
---

题目地址：nc warmup.game.redbud.info 20002  

题目提示：fork, fork, fork  

题目文件：[https://xuanxuanblingbling.github.io/assets/pwn/warmup](https://xuanxuanblingbling.github.io/assets/pwn/warmup)


## 检查保护

首先是检查文件和检查保护，可见是没去符号的64位的ELF文件，GOT表不可写，栈不可执行：

```bash
➜   file warmup 
warmup: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/l, for GNU/Linux 2.6.32, BuildID[sha1]=f3148cd6d2c5c9fabf36ec3a7f251f9e02bd7abb, not stripped
➜   checksec warmup 
[*] '/Users/Desktop/warmup'
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
```

## 任意地址读写

ida64打开，f5看main函数结果中有错误提示，并且init函数参数有红色提示，点进init函数再回到main函数中错误消失，main函数逻辑如下：

```c
int __cdecl __noreturn main(int argc, const char **argv, const char **envp)
{
  const void *s; // [rsp+10h] [rbp-10h]
  unsigned __int64 v4; // [rsp+18h] [rbp-8h]

  v4 = __readfsqword(0x28u);
  init();
  memset(&s, 0, 8uLL);
  write(1, "What do you want to know:\n", 0x1AuLL);
  read(0, &s, 8uLL);                                // 输入8个字节到栈上的变量s
  write(1, "and here it is: ", 0x10uLL);
  write(1, s, 8uLL);                                // 获得以输入8个字节（s变量）为地址处的8个字节
  write(1, "\n", 1uLL);
  write(1, "What do you wanna say to Zhou Qi?\n", 0x22uLL);
  read(0, &ptr, 0x40uLL);                           // 输入0x40个字节到bss段上
  memset(&s, 0, 8uLL);                              // 栈上的s变量清空
  write(1, "Now you can change the world!\n", 0x1EuLL);
  read(0, &s, 8uLL);                                // 输入8个字节到栈上的变量s
  read(0, (void *)s, 8uLL);                         // 向以输入8个字节（s变量）为地址处的内存写入8个字节
  if ( fork() )
  {
    write(1, "Is there a race?\n", 0x11uLL);
    exit(0);
  }
  write(1, "ziiiro will give you one chance:)\n", 0x21uLL);
  read(0, &s, 0x50uLL);
  exit(0);
}
```

所以我们当前的能力就是：

- 一次任意地址读8个字节
- 一次任意地址写8个字节

故这道题并不是说考察发现漏洞的能力，而是有了以上两种能力后如何利用？如何劫持程序流？单说劫持程序流这事，超哥课上讲的，一般可以动手的地方有如下三处：

- 间接跳转（jmp和call的间接跳转，如函数指针的调用，GOT表等）
- 栈上的返回地址
- 异常处理函数

其实我觉得，异常处理函数也应该算作间接跳转，因为也应该是call一个函数指针，所以当我们动不了栈时，就应该找接下来的地方有哪些可以控制的间接跳转的地址。我做pwn题还少，就仅仅知道写GOT表和.fini_array，这道题GOT表不可写，main函数也没有return，所以.fini_array段的函数也不会执行，哪还有那些间接跳转可利用呢？

## 说说libc的那些函数 

以下的wp都提到了exit函数，那我们就以exit函数为例：

- [从TokyoWesterns 2019一道题谈谈在exit中的利用机会](https://xz.aliyun.com/t/6260)
- [TokyoWesterns CTF 2019 格式化漏洞利用的新姿势](https://www.anquanke.com/post/id/185709)
- [详解 De1ctf 2019 pwn——unprintable](https://www.anquanke.com/post/id/183859)

以上大概说的是，libc的exit函数的某种利用方式，也就是说，在libc的某些函数里，存在着一些函数指针的调用，如果我们能修改这些函数指针，那么当调用这些libc的函数时，程序也可以被劫持。那么这些libc的函数里会不会有函数指针的调用呢？如果有这些函数指针放在哪呢？可以修改么？这个问题可以通过阅读分析libc的源码得知：

- [libc源码](https://mirrors.syringanetworks.net/gnu/libc/)

如何分析libc的源码呢，网友都是一带而过，分析出exit里存在函数指针：

```c
 RUN_HOOK (__libc_atexit, ());
```

我整个libc的源码里都没搜到__libc_atexit这个函数指针在哪定义的，也看不出这个函数指针放在哪，是否能修改。RUN_HOOK这个方法本身也是个复杂的宏定义，所以我觉得在源码层面，编码者有很多编码技巧，而这些技巧会阻碍我们理解程序真正的运行方法，所以我目前的思路是直接用IDA F5后的结果看这些libc函数，我觉得看着比源码清楚，因为如果是函数指针，IDA就会注释出来相应的函数原型，而且也直接能看到变量后会跟括号进行调用。比如


## fork函数

本题的提示是fork，那fork函数中有没有可以用的函数指针呢？


## 利用

### 泄露libc基址

### 修改函数指针

### 完整exp






