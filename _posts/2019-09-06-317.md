---
title: 和媳妇一起学Pwn 之 3x17
date: 2019-09-06 00:00:00
categories:
- CTF/Pwn
tags: 符号表 任意地址写 fini_array 栈迁移 ROP ROPgadget pwnable.tw
---

题目地址：[https://pwnable.tw/challenge/#32](https://pwnable.tw/challenge/#32)

非常非常巧妙的一道题目，参考wp

- [3 x 17](https://ama2in9.top/2019/04/10/3x17/)
- [pwnable.tw 3x17 writeup](https://v1ckydxp.github.io/2019/04/26/pwnable-tw-3x17-writeup/)
- [pwnable.tw_3x17](https://www.jianshu.com/p/9af1cce12e92)
- [3*17](https://www.jianshu.com/p/d98f0b7c8ff1)
- [pwnable.tw系列](https://n0va-scy.github.io/2019/07/03/pwnable.tw/)

## 检查

运行一下是先让输入addr后输入data，感觉像是任意地址写，按照惯例先检查一下文件：

```bash
➜  file 3x17 
3x17: ELF 64-bit LSB executable, x86-64, version 1 (GNU/Linux), statically linked, for GNU/Linux 3.2.0, BuildID[sha1]=a9f43736cc372b3d1682efa57f19a4d5c70e41d3, stripped
➜  checksec 3x17 
[*] '/mnt/hgfs/\xe6\xa1\x8c\xe9\x9d\xa2/pwnable/317/3x17'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
```

是个静态链接的ELF，然后还去了符号表，开启了栈不可执行。因为是静态链接，还去了符号表，所以什么符号都没有，所以如果用IDA分析还需要找一下main函数。

这里有两种办法：

- 了解_start函数的结构，当调用__libc_start_main时，rdi中的参数即为main函数
- 运行程序，通过打印的字符串交叉引用找到main函数

这里我们编译一个没去符号的程序，然后对比其_start函数与3x17中的start（IDA自己加的符号）函数：

![image](https://xuanxuanblingbling.github.io/assets/pic/317/start.png)

可见除了一个不知道哪来的67h，是完全可以对应上的，对于64位的ELF程序参数传递顺序可以参考：[https://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/stack-intro-zh/](https://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/stack-intro-zh/)，即System V AMD64 ABI (Linux、FreeBSD、macOS 等采用) 中前六个整型或指针参数依次保存在 RDI, RSI, RDX, RCX, R8 和 R9 寄存器中，如果还有更多的参数的话才会保存在栈上

所以__libc_start_main的函数原型：

```c
__libc_start_main(main,argc,argv&env,init,fini,rtld_fini)
```

对应即：

sub_401B6D: main
sub_402960: fini
sub_401EB0: __libc_start_main

可以用快捷键n，在IDA中对函数或者变量等进行重命名

## 漏洞点

进入主函数，IDA的f5有时候会识别有些问题，点进去这些函数，然后再出来，可能就识别正确了，main函数如下，很明显sub_446EC0是write,sub_446E20是read，这里直接改名了：

```c
int __cdecl main(int argc, const char **argv, const char **envp)
{
  int result; // eax
  char *v4; // ST08_8
  char buf; // [rsp+10h] [rbp-20h]
  unsigned __int64 v6; // [rsp+28h] [rbp-8h]

  v6 = __readfsqword(0x28u);
  result = (unsigned __int8)++byte_4B9330;
  if ( byte_4B9330 == 1 )
  {
    write(1u, "addr:", 5uLL);
    read(0, &buf, 0x18uLL);
    v4 = (char *)(signed int)sub_40EE70((__int64)&buf);
    write(1u, "data:", 5uLL);
    read(0, v4, 0x18uLL);
    result = 0;
  }
  if ( __readfsqword(0x28u) != v6 )
    sub_44A3E0();
  return result;
}
```

在以上参考的wp中，通过他们的IDA截图中可以看到，有的是有符号表的，有的是没有的。所以估计这题目的文件是去了符号表有换上来的。分析大概逻辑就知道，就是一个对读进来的地址进行一个变换，然后去写这个地址，变换函数是sub_40EE7，静态看这个函数没看明白，但是那个没去符号表的截图中显示这个函数叫：strtol。用man命令或者查找手册[C library function - strtol()](http://www.tutorialspoint.com/c_standard_library/c_function_strtol.htm)，都能知道这是一个把字符转成整形的函数。

但是，不知道这个函数是啥咋整？

- [利用ida pro的flare功能识别静态链接函数签名](https://blog.csdn.net/qq_29343201/article/details/74656456)
- 动态调试看看啥结果

第一种办法导入函数签名的那个刚才试了一个小时，扔到ida的sig文件夹下在开也没啥反应，暂时还没搞明白。这里先看一下动态调试，由于没开启地址随机化，我们可以直接打断（因为没有任何符号，所以也不能用符号打断，_start都不能用）：

```bash
# 我们就断在401BF2这里，然后看看rax和我们输入的是什么关系就行了

.text:0000000000401BED                 call    sub_40EE70
.text:0000000000401BF2                 cdqe

➜  gdb -q 3x17
Reading symbols from 3x17...(no debugging symbols found)...done.
gdb-peda$ b * 0x401BF2
Breakpoint 1 at 0x401bf2
gdb-peda$ r
Starting program: /mnt/hgfs/桌面/pwnable/317/3x17 
addr:1111

[----------------------------------registers-----------------------------------]
RAX: 0x457 
```

发现0x457就是1111的十六进制，即我们输入的地址就是要写的地址的十进制形式，所以可以写的地址是所有地址，所以这到题的漏洞点就是**任意地址写**，最多0x18个字节。

也就是说我们目前只有一次机会，这一次能写0x18个字节，而且我们不知道栈在哪，如何劫持RIP？

而且有个很奇怪的地方，在main函数中有个变量byte_4B9330，位于bss段，初值为0，运行时会自增1，只有当这个变量为1时才能写。这玩意有啥用？对于我来说本就是一次机会啊，加不加的又能怎样？

## 利用

现在我们有 一次 任意地址 写 0x18 个字节的能力，如何利用呢？

### 一次写变多次写

> 杨慧兰：这三根金针啊，代表三个愿望，我可以满足你三个愿望！
> 李大嘴：那，我的第一个愿望————你能在给我三十个愿望么？

#### main函数的启动过程

关于main函数的启动，可以参考《程序员的我修养》第11章第1节，当然并没有下面讲的细致：

还记的__libc_start_main的几个参数里有两个东西么（init,fini），这俩是个啥呢？

```
.text:0000000000401A5F                 mov     r8, offset sub_402960
.text:0000000000401A66                 mov     rcx, offset loc_4028D0
```

这俩其实就是两个函数的地址，分别是：__libc_csu_fini（sub_402960），__libc_csu_init（loc_4028D0），至于为啥init的被IDA识别成loc，就不知道了。因为是静态编译的，这两个本身是libc的函数，但是可以在这个二进制中直接点进去看到函数的实现。

> csu是啥意思？[What does CSU in glibc stand for?](https://stackoverflow.com/questions/32725541/what-does-csu-in-glibc-stand-for),即 "C start up"

顾名思义，一个是init，开始时函数。一个是fini，结束时的函数。所以可见main函数的地位并没有我们刚接触c语言是那么至高无上，他既不是程序执行时的第一个函数，也不是最后一个函数。那启动流程到底是啥样的呢？网友分析如下：

[linux编程之main()函数启动过程](https://blog.csdn.net/gary_ygl/article/details/8506007

另外在IDA的 view -> open subviews -> segments可以看到如下四个段：

- .init
- .init_array
- .fini
- .fini_array

点进去即可看到.init和.fini是可执行的段，是代码，是函数。而.init_array和.fini_array是数组，里面存着函数的地址，这两个数组里的函数由谁来执行呢？

其实就是：__libc_csu_fini和__libc_csu_init

这里.init和.init_array中的函数，以及.fini和.fini_array的函数，如何把自己编写的函数放到这四个地方里，之前我写过笔记，[Android动态链接库so的加载与调试](https://xuanxuanblingbling.github.io/ctf/android/2018/02/23/so/)，但是后来尝试的时候好像有个地方错了，我还没具体研究，但总经过分析glibc的源码

- [glibc/csu/libc-start.c](https://github.com/lattera/glibc/blob/895ef79e04a953cac1493863bcae29ad85657ee1/csu/libc-start.c)
- [glibc/csu/elf-init.c](https://github.com/lattera/glibc/blob/895ef79e04a953cac1493863bcae29ad85657ee1/csu/elf-init.c)，可知：


- __libc_csu_init执行.init和.init_array
- __libc_csu_fini执行.fini和.fini_array

并且执行顺序如下：

- __libc_csu_init
- main
- __libc_csu_fini

更细致的说顺序如下：

- .init
- .init_array[0] 
- .init_array[1] 
- ... 
- .init_array[n] 
- main 
- .fini_array[n]
- ... 
- .fini_array[1]
- .fini_array[0]
- .fini


#### __libc_csu_fini

让我们来看一下这个函数的实现吧，也就是题目中的sub_402960：

```c
.text:0000000000402960 sub_402960      proc near               ; DATA XREF: start+F↑o
.text:0000000000402960 ; __unwind {
.text:0000000000402960                 push    rbp
.text:0000000000402961                 lea     rax, unk_4B4100
.text:0000000000402968                 lea     rbp, off_4B40F0 ; fini_array
.text:000000000040296F                 push    rbx
.text:0000000000402970                 sub     rax, rbp
.text:0000000000402973                 sub     rsp, 8
.text:0000000000402977                 sar     rax, 3
.text:000000000040297B                 jz      short loc_402996
.text:000000000040297D                 lea     rbx, [rax-1]
.text:0000000000402981                 nop     dword ptr [rax+00000000h]
.text:0000000000402988
.text:0000000000402988 loc_402988:                             ; CODE XREF: sub_402960+34↓j
.text:0000000000402988                 call    qword ptr [rbp+rbx*8+0] ; 调用fini_array的函数
.text:000000000040298C                 sub     rbx, 1
.text:0000000000402990                 cmp     rbx, 0FFFFFFFFFFFFFFFFh
.text:0000000000402994                 jnz     short loc_402988
.text:0000000000402996
.text:0000000000402996 loc_402996:                             ; CODE XREF: sub_402960+1B↑j
.text:0000000000402996                 add     rsp, 8
.text:000000000040299A                 pop     rbx
.text:000000000040299B                 pop     rbp
.text:000000000040299C                 jmp     sub_48E32C
.text:000000000040299C ; } // starts at 402960
.text:000000000040299C sub_402960      endp
```

当然也可以对照glibc的源码：

[glibc/csu/elf-init.c](https://github.com/lattera/glibc/blob/895ef79e04a953cac1493863bcae29ad85657ee1/csu/elf-init.c)

```c
__libc_csu_fini (void)
{
#ifndef LIBC_NONSHARED
  size_t i = __fini_array_end - __fini_array_start;
  while (i-- > 0)
    (*__fini_array_start [i]) ();

# ifndef NO_INITFINI
  _fini ();
# endif
#endif
}
```

所以无论是看汇编还是源码，都能看出来，.fini_array数组中的函数是倒着调用的。题目中的off_4B40F0这个地址，就是.fini_array：

```c
.fini_array:00000000004B40F0 ; Segment type: Pure data
.fini_array:00000000004B40F0 ; Segment permissions: Read/Write
.fini_array:00000000004B40F0 ; Segment alignment 'qword' can not be represented in assembly
.fini_array:00000000004B40F0 _fini_array     segment para public 'DATA' use64
.fini_array:00000000004B40F0                 assume cs:_fini_array
.fini_array:00000000004B40F0                 ;org 4B40F0h
.fini_array:00000000004B40F0 off_4B40F0      dq offset sub_401B00    ; DATA XREF: .text:000000000040291C↑o
.fini_array:00000000004B40F0                                         ; sub_402960+8↑o
.fini_array:00000000004B40F8                 dq offset sub_401580
.fini_array:00000000004B40F8 _fini_array     ends
.fini_array:00000000004B40F8
```

#### 覆写.fini_array

这道题.fini_array中有两个函数，则我可以知道函数的执行顺序：

```
+---------------------+             +---------------------+              +---------------------+             +---------------------+
|                     |             |                     |              |                     |             |                     |
|       main          |  +--------> |  __libc_csu_fini    |  +------->   |  .fini_array[1]     |  +------->  |   .fini_array[0]    |
|                     |             |                     |              |                     |             |  _                  |
+---------------------+             +---------------------+              +---------------------+             +---------------------+

```

所以我们如果如果把.fini_array[1]覆盖成main，把 .fini_array[0]覆盖成 __libc_csu_fini，执行顺序就会变成这样

```
+---------------------+             +---------------------+              +---------------------+             +---------------------+
|                     |             |                     |              |                     |             |                     |
|       main          |  +--------> |  __libc_csu_fini    |  +------->   |  .fini_array[1]     |  +------->  |   .fini_array[0]    |
|                     |             |                     |              |  (main)             |             |  __libc_csu_fini    |
+---------------------+             +---------------------+              +---------------------+             +---------------------+

                                                                                     ^                                  +
                                                                                     |                                  |
                                                                                     +----------------------------------+
```



### 栈迁移

### ROP

## exp

