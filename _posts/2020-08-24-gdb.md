---
title: HWS夏令营 之 GDB调一切
date: 2020-08-24 00:00:00
categories:
- CTF/Pwn
tags: GDB
---

> HWS夏令营的课程分为三个部分，IoT固件安全，linux内核安全、IoT硬件安全。GDB作为一个出色的调试工具，也在三个部分的课程中频频登场，说哪都有他一点也不过分。三个部分中，我们用GDB依次调试了：arm,mips等与本机x86（x64）不同架构的linux用户态应用程序、x86（x64）的linux内核、STM32裸机程序。前两者目标的运行方法是qemu，后者是用的STM32单板以及JLINK仿真器。

平日我们在linux中调试用户态程序时，直接使用gdb命令即可，但是如果是我们无法在目标系统上执行gdb，或者目标系统并不直接支持程序状态的监视，那么我们怎么去调试呢？gdb支持远程调试，即gdb这个client和远程的gdbserver通信，所以只要在目标系统之下的层面跑起来gdbserver即可。以下三种目标都是这种情况，你无法直接使用gdb和二进制文件就将程序跑起来，而是需要一个能监视目标程序的底层系统，并且这个系统需要支持gdbserver。

## 调试arm,mips架构linux的用户态程序

当然你可以使用arm，mips的真机，然后在上面安装gdb或者拷贝一个gdbserver进去，比如树莓派。不过qemu可以帮我们省去购买真机开销，而且对于一些特殊情况的程序，可能真机反倒会带来麻烦，一会我会举个例子。先看以下三个目标：

```c
➜  file typo 
typo: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), statically linked, for GNU/Linux 2.6.32, BuildID[sha1]=211877f58b5a0e8774b8a3a72c83890f8cd38e63, stripped
➜  file embedded_heap 
embedded_heap: ELF 32-bit MSB shared object, MIPS, MIPS32 rel2 version 1 (SYSV), dynamically linked, interpreter /lib/ld-uClibc.so.0, stripped
➜  file tpra_sr20v1.bin 
tpra_sr20v1.bin: data
```

1. 只有一个elf文件，静态链接
2. elf动态链接，以及相关的动态链接库
3. 整个固件，需要提取文件系统

所以如果仅仅是提供了elf文件，则可以使用qemu-user直接启动。如果给出了文件系统，则可以使用qemu-system。不过二者对于用户态程序来说并没有什么本质的区别，也可以将给的单个的elf文件里扔到文件系统然后用qemu-system，也可以将文件系统中的模目标要pwn的程序拿出来用qemu-user。具体使用什么策略要看目标的情况，方便就好。

### qemu-user

#### typo

qemu-arm这种qemu-user模式下，`-g`选项是开始gdb调试：

```c
➜  qemu-arm -h | grep gdb
-g port       QEMU_GDB          wait gdb connection to 'port'
➜  qemu-arm -g 1234 ./typo
```

这样既可开启一个1234端口的gdbserver，然后即可在另一个terminal中使用gdb的`target remote`命令进行连接，不过在连接之前先设置目标的指令集和大小端，然后连接：

```c
➜  gdb-multiarch -q ./typo
pwndbg> set architecture arm
The target architecture is assumed to be arm
pwndbg> set endian little
The target is assumed to be little endian
pwndbg> target remote :1234
Remote debugging using :1234
0x00008b98 in ?? ()
LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA
─────────────────────────────────[ REGISTERS ]──────────────────────────────────
 R0   0x0
 R1   0xf6fff1cc ◂— './typo'
 R2   0x0
 R3   0x0
 R4   0x0
 R5   0x0
 R6   0x0
 R7   0x0
 R8   0x0
 R9   0x0
 R10  0x8af6c —▸ 0xa1e94 —▸ 0x6ff44 —▸ 0x7b918 ◂— andeq  r0, r0, r3, asr #32 /* 'C' */
 R11  0x0
 R12  0x0
 SP   0xf6fff000 ◂— 0x1
 PC   0x8b98 ◂— mov    fp, #0
───────────────────────────────────[ DISASM ]───────────────────────────────────
 ► 0x8b98    mov    fp, #0
   0x8b9c    mov    lr, #0
   0x8ba0    pop    {r1}
   0x8ba4    mov    r2, sp
   0x8ba8    str    r2, [sp, #-4]!
   0x8bac    str    r0, [sp, #-4]!
   0x8bb0    ldr    ip, [pc, #0x10]
   0x8bb4    str    ip, [sp, #-4]!
   0x8bb8    ldr    r0, [pc, #0xc]
   0x8bbc    ldr    r3, [pc, #0xc]
   0x8bc0    bl     #0x9ebc
───────────────────────────────────[ STACK ]───────
```
#### embedded_heap

如果带动态链接库的二进制文件，可以使用qemu-user的`-L`选项使用当前目录，然后动态库存放于当目录的子目录中：

```c
➜  file embedded_heap
embedded_heap: ELF 32-bit MSB shared object, MIPS, MIPS32 rel2 version 1 (SYSV), dynamically linked, interpreter /lib/ld-uClibc.so.0, stripped
➜  ls *
embedded_heap

lib:
ld-uClibc-0.9.33.2.so  ld-uClibc.so.0  libc.so.0  libuClibc-0.9.33.2.so
➜  qemu-mips -L ./ ./embedded_heap 
/lib/ld-uClibc.so.0: Invalid ELF image for this architecture
```

这里报错：`Invalid ELF image`，是因为给的文件是从文件系统中提取出来的，提取的过程把链接文件弄错了。正常来说`ld-uClibc.so.0`应该是一个链接文件，指向`ld-uClibc-0.9.33.2.so`，`libc.so.0`也一样，我们可以看一下这俩文件：

```c
➜  ls ./lib/libc.so.0 
./lib/libc.so.0
➜  ls ./lib/ld-uClibc.so.0 
./lib/ld-uClibc.so.0
```

可以看到这俩文件压根就是文本文件，所以把这俩删掉，然后把另外两个动态库的实体改成链接文件的名即可：

```c
➜  rm -rf libc.so.0 
➜  rm -rf ld-uClibc.so.0 
➜  mv libuClibc-0.9.33.2.so libc.so.0
➜  mv ld-uClibc-0.9.33.2.so ld-uClibc.so.0
➜  cd ..
➜  qemu-mips -g 1234 -L ./ ./embedded_heap 
```

然后仍然是设置目标的指令集和大小端，最后连接上即可：

```c
➜  gdb-multiarch -q ./embedded_heap
pwndbg: loaded 180 commands. Type pwndbg [filter] for a list.
pwndbg: created $rebase, $ida gdb functions (can be used with print/break)
Reading symbols from ./embedded_heap...(no debugging symbols found)...done.
pwndbg> set architecture mips
The target architecture is assumed to be mips
pwndbg> set endian big
The target is assumed to be big endian
pwndbg> target remote :1234
Remote debugging using :1234
warning: remote target does not support file transfer, attempting to access files from local filesystem.
Reading symbols from /mnt/hgfs/桌面/hws/gdb调一切/embedded_heap/lib/ld-uClibc.so.0...(no debugging symbols found)...done.
0x767d4f80 in _start () from /mnt/hgfs/桌面/hws/gdb调一切/embedded_heap/lib/ld-uClibc.so.0
LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA
───────────────────────────────────────────[ REGISTERS ]────────────────────────────────────────────
 V0   0x0
 V1   0x0
 A0   0x0
 A1   0x0
 A2   0x0
 A3   0x0
 T0   0x0
 T1   0x0
 T2   0x0
 T3   0x0
 T4   0x0
 T5   0x0
 T6   0x0
 T7   0x0
 T8   0x0
 T9   0x0
 S0   0x0
 S1   0x0
 S2   0x0
 S3   0x0
 S4   0x0
 S5   0x0
 S6   0x0
 S7   0x0
 S8   0x0
 FP   0x76febfd0 ◂— 0x1
 SP   0x76febfd0 ◂— 0x1
 PC   0x767d4f80 (_start) ◂— move   $t9, $ra
─────────────────────────────────────────────[ DISASM ]─────────────────────────────────────────────
 ► 0x767d4f80 <_start>       move   $t9, $ra
   0x767d4f84 <_start+4>     bal    _start+12 <0x767d4f8c>
   0x767d4f88 <_start+8>     nop    
   0x767d4f8c <_start+12>    lui    $gp, 2
   0x767d4f90 <_start+16>    addiu  $gp, $gp, -0x1f7c
   0x767d4f94 <_start+20>    addu   $gp, $gp, $ra
   0x767d4f98 <_start+24>    move   $ra, $t9
   0x767d4f9c <_start+28>    lw     $a0, -0x7fe8($gp)
   0x767d4fa0 <_start+32>    sw     $a0, -0x7ff0($gp)
   0x767d4fa4 <_start+36>    move   $a0, $sp
   0x767d4fa8 <_start+40>    addiu  $sp, $sp, -0x10
─────────────────────────────────────────────[ STACK ]──────────────────────────────────────────────
00:0000│ fp sp  0x76febfd0 ◂— 0x1
01:0004│        0x76febfd4 —▸ 0x76fec18c ◂— './embedded_heap'
02:0008│        0x76febfd8 ◂— 0x0
03:000c│        0x76febfdc —▸ 0x76fec19c ◂— '_=/usr/bin/qemu-mips'
04:0010│        0x76febfe0 —▸ 0x76fec1b1 ◂— 0x4c535f43 ('LS_C')
05:0014│        0x76febfe4 —▸ 0x76fec739 ◂— 'LSCOLORS=Gxfxcxdxbxegedabagacad'
06:0018│        0x76febfe8 —▸ 0x76fec759 ◂— 'LC_CTYPE=en_US.UTF-8'
07:001c│        0x76febfec —▸ 0x76fec76e ◂— 'LESS=-R'
───────────────────────────────────────────[ BACKTRACE ]────────────────────────────────────────────
 ► f 0 767d4f80 _start
────────────────────────────────────────────────────────────────────────────────────────────────────
pwndbg> vmmap
LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA
0x767d4000 0x767db000 r-xp     7000 0      [linker]
0x767d4000 0x767db000 r-xp     7000 0      /mnt/hgfs/桌面/hws/gdb调一切/embedded_heap/lib/ld-uClibc.so.0
0x767db000 0x767ea000 ---p     f000 6000   [linker]
0x767db000 0x767ea000 ---p     f000 6000   /mnt/hgfs/桌面/hws/gdb调一切/embedded_heap/lib/ld-uClibc.so.0
0x767ea000 0x767eb000 r--p     1000 6000   [linker]
0x767ea000 0x767eb000 r--p     1000 6000   /mnt/hgfs/桌面/hws/gdb调一切/embedded_heap/lib/ld-uClibc.so.0
0x767eb000 0x767ec000 rw-p     1000 7000   [linker]
0x767eb000 0x767ec000 rw-p     1000 7000   /mnt/hgfs/桌面/hws/gdb调一切/embedded_heap/lib/ld-uClibc.so.0
0x76fea000 0x76fed000 rw-p     3000 0      [stack]
0x76fed000 0x76fef000 r-xp     2000 0      /mnt/hgfs/桌面/hws/gdb调一切/embedded_heap/embedded_heap
0x76fef000 0x76ffe000 ---p     f000 1000   /mnt/hgfs/桌面/hws/gdb调一切/embedded_heap/embedded_heap
0x76ffe000 0x76fff000 r--p     1000 1000   /mnt/hgfs/桌面/hws/gdb调一切/embedded_heap/embedded_heap
0x76fff000 0x77000000 rw-p     1000 2000   /mnt/hgfs/桌面/hws/gdb调一切/embedded_heap/embedded_heap
pwndbg> 
```

#### 总结

1. 可以用pwndbg插件的vmmap来观察程序内存，这里的内存是qemu模拟出来的，宿主机上并不存在`embedded_heap`这个进程，因为gdbserver本身就是qemu自己提供的支持，所以他可以给gdb一个模拟出来的假的内存布局。
2. 经过测试，peda、gef、pwndbg三款插件，pwndbg对于qemu-user的gdbserver支持是最好的，另两个很多东西都看不到。
3. 可以看到这里识别embedded_heap的内存中没有libc.so.0，但是在qemu模拟的内存中，libc的确存在，需要自行在目标程序中打断，然后分析libc地址，如果采用qemu-system方法启动一整个文件系统，将不会出现这种情况。
4. 使用qemu-user模式下的自带的gdbserver，gdb调试时无法使用control+c发送SIGINT，也就无法使程序随意断下，必须通过手动下断点的方式调试程序。

### qemu-system

面对第三个固件`tpra_sr20v1.bin`我们首先需要使用binwalk来进行分析以及解包：

```
$ binwalk -Me tpra_sr20v1.bin 
```

这样就可以直接将固件中包含的squashfs文件系统直接解包出来，对于这种带文件系统固件且没有在固件中提取出linux内核的bzImage文件的情况下，我们一般采用qemu-system启动一个和固件指令集相同的linux系统，然后将固件的文件系统打包扔进去并chroot，然后即可使用该指令集下静态编译好的gdbserver对目标程序进行附加，最后在宿主机使用gdb连接远程即可开始调试。

- 各种指令集的linux内核以及文件系统可以在这里获得: [https://people.debian.org/~aurel32/qemu/](https://people.debian.org/~aurel32/qemu/)
- 各种指令集的静态编译的gdbserver已经上传到百度网盘: [https://pan.baidu.com/s/1_Grqzwyf3NOesbWLp6gBKg](https://pan.baidu.com/s/1_Grqzwyf3NOesbWLp6gBKg) 密码:hfab

## 调试linux内核

- 如果是从源码编译linux内核以及手动构建文件系统可以参考: [linux kernel 爬坑记录](https://s3cunda.github.io/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/2018/09/21/linux-kernel-%E7%88%AC%E5%9D%91%E8%AE%B0%E5%BD%95.html)
- 也可以使用这里给出的基本环境直接理解调试的原理: [https://pan.baidu.com/s/1fGyB5JcCdCXYTkW3Ez_dwA](https://pan.baidu.com/s/1fGyB5JcCdCXYTkW3Ez_dwA) 密码:uhj6

基本环境中有如下文件：

- bzImage: 压缩的linux内核
- vmlinux: 未压缩的linux内核，ELF格式，可以由bzImage解压得到
- rootfs.img: 根目录的文件系统 
- dev_helper.ko: 编译好的驱动模块，也是要分析的目标
- startQemu.sh: qemu的启动脚本


```
$ qemu-system-x86_64 -m 2G -kernel ./bzImage -drive file=./rootfs.img -append "console=ttyS0 root=/dev/sda earlyprintk=serial nokaslr" -nographic -s
```

```
gdb ./vmlinux
target remote :1234
add-symbol-file ./dev_helper.ko 0xffffffffc0008000
info reg
```

## 调试STM32裸机程序

对于STM32之前我是有过介绍的：[SCTF 2020 Password Lock Plus 入门STM32逆向](https://xuanxuanblingbling.github.io/iot/2020/07/08/stm32/)，keil可以对STM32真机进行调试，但我们编写的例程一般是裸机程序，与前两者qemu提供的调试不同，这里看起来没有更底层的软件能来帮我们监视STM32的程序状态了，那么keil能对STM32真机调试的原理是什么呢？没错，就是硬件。这里我们暂时不讲硬件调试的接口以及原理，我们使用STM32开发板以及JINK仿真器，并按照如下方式连接：

![image](https://xuanxuanblingbling.github.io/assets/pic/gdb/gdb.jpeg)



然后安装[openocd(Open On-Chip Debugger)](http://openocd.org/)工具，启动并指明仿真器以及目标板子的型号：

```c
➜  brew install openocd
➜  cd /usr/local/Cellar/open-ocd/0.10.0/share/openocd/
➜  openocd -f ./interface/jlink.cfg -f target/stm32f1x.cfg
```

这个工具的原理和安装参考：

- [跟我一起学OpenOCD(一)](https://zhuanlan.zhihu.com/p/41517198)
- [OpenOCD install on MacOS](http://regishsu.blogspot.com/2018/06/stm32f4x-openocd-install-on-macos.html)

启动之后会开启以下三个端口：

```c
➜  ~ lsof -nP  -i | grep openocd
openocd   7820    3u  IPv4 0x4db37f3eeec1ba61      0t0  TCP *:6666 (LISTEN)
openocd   7820    4u  IPv4 0x4db37f3eeb900bc1      0t0  TCP *:4444 (LISTEN)
openocd   7820    7u  IPv4 0x4db37f3eeb808441      0t0  TCP *:3333 (LISTEN)
```

其中4444是openocd的命令行端口：

```c
➜  ~ telnet localhost 4444
Trying ::1...
Connection failed: Connection refused
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
Open On-Chip Debugger
> help
adapter_khz [khz]
      With an argument, change to the specified maximum jtag speed.  For
      JTAG, 0 KHz signifies adaptive  clocking. With or without argument,
      display current setting. (command valid any time)
adapter_name
      Returns the name of the currently selected adapter (driver) (command
      valid any time)
adapter_nsrst_assert_width [milliseconds]
      delay after asserting SRST in ms (command valid any time)
adapter_nsrst_delay [milliseconds]
      delay after deasserting SRST in ms (command valid any time)
add_help_text command_name helptext_string
      Add new command help text; Command can be multiple tokens. (command
      valid any time)
...
```

而启动的3333端口就可以使用gdb进行连接并调试了，仍然是设置指令集以及连接远程。比如这里我烧写了一个跑马灯的例程，然后将断点打在开关灯处`0x08000506`，即可断下：

```c
➜  ~ gdb -q 
gdb-peda$ set architecture armv7e-m
The target architecture is assumed to be armv7e-m
gdb-peda$ target remote :3333
Remote debugging using :3333
warning: No executable has been specified and target does not support
determining executable automatically.  Try using the "file" command.
0x00000000 in ?? ()
gdb-peda$ b * 0x8000506
Breakpoint 1 at 0x8000506
gdb-peda$ c
Continuing.
Note: automatically using hardware breakpoints for read-only addresses.
WARNING! The target is already running. All changes GDB did to registers will be discarded! Waiting for target to halt.

Breakpoint 1, 0x08000506 in ?? ()

gdb-peda$ x /20i $pc
=> 0x8000506:	movs	r0, #0
   0x8000508:	ldr	r1, [pc, #40]	; (0x8000534)
   0x800050a:	str	r0, [r1, #0]
   0x800050c:	movs	r0, #1
   0x800050e:	ldr	r1, [pc, #40]	; (0x8000538)
   0x8000510:	str.w	r0, [r1, #392]	; 0x188
   0x8000514:	movw	r0, #3000	; 0xbb8
   0x8000518:	bl	0x80004b8
   0x800051c:	movs	r0, #1
   0x800051e:	ldr	r1, [pc, #20]	; (0x8000534)
   0x8000520:	str	r0, [r1, #0]
   0x8000522:	movs	r0, #0
   0x8000524:	ldr	r1, [pc, #16]	; (0x8000538)
   0x8000526:	str.w	r0, [r1, #392]	; 0x188
   0x800052a:	movw	r0, #3000	; 0xbb8
   0x800052e:	bl	0x80004b8
   0x8000532:	b.n	0x8000506
   0x8000534:	lsls	r0, r4, #6
   0x8000536:	tst	r1, r4
   0x8000538:	strh	r0, [r0, #0]

gdb-peda$ info reg
r0             0x10001             0x10001
r1             0xbb8               0xbb8
r2             0x0                 0x0
r3             0xe000e000          0xe000e000
r4             0x0                 0x0
r5             0x200000d4          0x200000d4
r6             0x0                 0x0
r7             0x0                 0x0
r8             0x0                 0x0
r9             0xff5ffffd          0xff5ffffd
r10            0x800055c           0x800055c
r11            0x0                 0x0
r12            0x20000114          0x20000114
sp             0x20000738          0x20000738
lr             0x8000533           0x8000533
pc             0x8000506           0x8000506
xPSR           0x61000000          0x61000000
msp            0x20000738          0x20000738
psp            0xc3b3fb58          0xc3b3fb58
primask        0x0                 0x0
basepri        0x0                 0x0
faultmask      0x0                 0x0
control        0x0                 0x0
```

这里其实openocd这个软件将jtag调试的过程转化为gdb调试的过程，所以这里的gdbserver是由openocd支持的，而真正的调试功能是硬件支持的，jtag是作为调试的电路接口以及一个标准协议出现调试中。


